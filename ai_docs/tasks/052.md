# Task 052: Multi-Region Deployment Infrastructure with Global Load Balancing

## Overview
Implement a robust multi-region deployment infrastructure that ensures high availability, disaster recovery, and optimal performance across global regions. This task focuses on designing and implementing geo-distributed architecture with intelligent traffic routing, data replication strategies, and regional failover capabilities to support enterprise-scale global operations.

## Success Criteria
- [ ] Multi-region deployment across 3+ geographical regions (US-East, EU-West, Asia-Pacific)
- [ ] Global load balancer routes traffic with <50ms latency to nearest healthy region
- [ ] Cross-region data replication achieves <5 minute RPO (Recovery Point Objective)
- [ ] Regional failover completes within 30 seconds with automatic traffic redirection
- [ ] Regional health monitoring detects failures within 15 seconds
- [ ] Cross-region database synchronization maintains 99.9% consistency

## Test First Approach

### Tests to Write BEFORE Implementation:

1. **Multi-Region Deployment Tests** (`tests/backend/unit/test_multi_region.py`):
```python
def test_regional_deployment_health():
    """Test health and availability of all regional deployments."""
    # Test deployment health in each region
    # Test service availability across regions
    # Test regional configuration consistency
    # Test network connectivity between regions
    # Test regional resource allocation

def test_global_load_balancing():
    """Test global load balancer traffic routing."""
    # Test geo-based traffic routing
    # Test latency-based routing decisions
    # Test health-based traffic redirection
    # Test load distribution accuracy
    # Test routing rule effectiveness

def test_regional_failover():
    """Test automatic regional failover mechanisms."""
    # Test regional failure detection
    # Test traffic redirection speed
    # Test service continuity during failover
    # Test data consistency during failover
    # Test recovery procedures
```

2. **Data Replication Tests** (`tests/backend/unit/test_data_replication.py`):
```python
def test_cross_region_replication():
    """Test cross-region data replication."""
    # Test replication latency and consistency
    # Test replication conflict resolution
    # Test replication failure recovery
    # Test replication bandwidth efficiency
    # Test replication monitoring accuracy

def test_database_synchronization():
    """Test database synchronization across regions."""
    # Test synchronous vs asynchronous replication
    # Test data consistency guarantees
    # Test synchronization failure handling
    # Test performance impact of synchronization
    # Test synchronization monitoring

def test_data_consistency():
    """Test data consistency across regions."""
    # Test eventual consistency behavior
    # Test conflict resolution strategies
    # Test consistency verification
    # Test inconsistency detection and repair
    # Test consistency under network partitions
```

3. **Regional Health Monitoring Tests** (`tests/backend/unit/test_regional_monitoring.py`):
```python
def test_regional_health_detection():
    """Test regional health monitoring systems."""
    # Test health check accuracy and speed
    # Test monitoring of critical services
    # Test alerting and notification systems
    # Test monitoring dashboard functionality
    # Test historical health data tracking

def test_failure_detection_speed():
    """Test speed of failure detection."""
    # Test detection within 15-second target
    # Test different failure scenario detection
    # Test monitoring system reliability
    # Test false positive rates
    # Test escalation procedures

def test_monitoring_integration():
    """Test integration between monitoring systems."""
    # Test data aggregation across regions
    # Test centralized monitoring dashboard
    # Test alert correlation and deduplication
    # Test monitoring data consistency
    # Test monitoring system failover
```

## Implementation Details

1. **Multi-Region Infrastructure Core** (`app/infrastructure/multi_region.py`):
```python
from typing import Dict, Any, List, Optional, Set, Union
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import asyncio
import json
import logging
import time
import ipaddress
from abc import ABC, abstractmethod

class Region(Enum):
    US_EAST_1 = "us-east-1"
    US_WEST_2 = "us-west-2"
    EU_WEST_1 = "eu-west-1"
    EU_CENTRAL_1 = "eu-central-1"
    ASIA_PACIFIC_1 = "ap-southeast-1"
    ASIA_PACIFIC_2 = "ap-northeast-1"

class RegionStatus(Enum):
    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    MAINTENANCE = "maintenance"
    FAILOVER = "failover"

class RoutingStrategy(Enum):
    GEOGRAPHIC = "geographic"
    LATENCY = "latency"
    ROUND_ROBIN = "round_robin"
    WEIGHTED = "weighted"
    HEALTH_BASED = "health_based"

@dataclass
class RegionConfig:
    region: Region
    location: Dict[str, float]  # lat, lon
    capacity: int
    priority: int
    endpoints: List[str]
    health_check_url: str
    database_config: Dict[str, Any]
    cdn_config: Dict[str, Any]
    monitoring_config: Dict[str, Any]

@dataclass
class RegionHealth:
    region: Region
    status: RegionStatus
    response_time_ms: float
    error_rate: float
    capacity_utilization: float
    last_check: datetime
    services_healthy: Dict[str, bool]
    metrics: Dict[str, Any] = field(default_factory=dict)

@dataclass
class TrafficRoute:
    source_region: str
    target_region: Region
    latency_ms: float
    bandwidth_mbps: float
    routing_weight: float
    last_updated: datetime

class MultiRegionManager:
    def __init__(self, regions: List[RegionConfig]):
        self.regions = {config.region: config for config in regions}
        self.region_health: Dict[Region, RegionHealth] = {}
        self.global_load_balancer: Optional['GlobalLoadBalancer'] = None
        self.data_replicator: Optional['DataReplicator'] = None
        self.failover_manager: Optional['FailoverManager'] = None
        
        # Traffic routing
        self.traffic_routes: Dict[str, List[TrafficRoute]] = {}
        self.routing_strategy = RoutingStrategy.LATENCY
        
        # Health monitoring
        self.health_monitors: Dict[Region, 'RegionHealthMonitor'] = {}
        self.global_health_aggregator: Optional['GlobalHealthAggregator'] = None
        
        # Performance metrics
        self.performance_metrics = {
            "global_response_time": 0.0,
            "cross_region_latency": {},
            "regional_utilization": {},
            "failover_count": 0,
            "replication_lag": {}
        }
        
        # Initialize components
        asyncio.create_task(self._initialize_multi_region())
        
    async def _initialize_multi_region(self):
        """Initialize multi-region infrastructure."""
        # Initialize regional health monitoring
        for region, config in self.regions.items():
            health = RegionHealth(
                region=region,
                status=RegionStatus.UNHEALTHY,
                response_time_ms=0.0,
                error_rate=0.0,
                capacity_utilization=0.0,
                last_check=datetime.utcnow(),
                services_healthy={}
            )
            self.region_health[region] = health
            
            # Create health monitor for each region
            self.health_monitors[region] = RegionHealthMonitor(config, health)
            
        # Initialize global load balancer
        self.global_load_balancer = GlobalLoadBalancer(
            regions=self.regions,
            health_provider=self._get_region_health,
            routing_strategy=self.routing_strategy
        )
        
        # Initialize data replication
        self.data_replicator = DataReplicator(
            regions=self.regions,
            replication_strategy="async_with_consistency_check"
        )
        
        # Initialize failover manager
        self.failover_manager = FailoverManager(
            regions=self.regions,
            health_provider=self._get_region_health,
            load_balancer=self.global_load_balancer
        )
        
        # Initialize global health aggregator
        self.global_health_aggregator = GlobalHealthAggregator(
            health_monitors=self.health_monitors
        )
        
        # Start background tasks
        asyncio.create_task(self._health_monitoring_loop())
        asyncio.create_task(self._traffic_optimization_loop())
        asyncio.create_task(self._replication_monitoring_loop())
        asyncio.create_task(self._performance_collection_loop())
        
        # Initialize traffic routes
        await self._initialize_traffic_routes()
        
        logging.info(f"Multi-region infrastructure initialized with {len(self.regions)} regions")
        
    async def route_request(self, request: 'Request', 
                          client_location: Optional[Dict[str, float]] = None) -> Dict[str, Any]:
        """Route request to optimal region."""
        start_time = time.time()
        
        try:
            # Determine optimal region for request
            target_region = await self.global_load_balancer.select_region(
                request, client_location
            )
            
            if not target_region:
                raise Exception("No healthy regions available")
                
            # Execute request in target region
            result = await self._execute_request_in_region(request, target_region)
            
            # Update performance metrics
            response_time = (time.time() - start_time) * 1000
            await self._update_routing_metrics(target_region, response_time, True)
            
            return {
                "result": result,
                "target_region": target_region.value,
                "response_time_ms": response_time,
                "routing_strategy": self.routing_strategy.value,
                "timestamp": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            # Handle routing failure and attempt failover
            response_time = (time.time() - start_time) * 1000
            await self._handle_routing_failure(request, str(e), response_time)
            
            return {
                "error": str(e),
                "response_time_ms": response_time,
                "timestamp": datetime.utcnow().isoformat()
            }
            
    async def trigger_regional_failover(self, failed_region: Region, 
                                      reason: str) -> Dict[str, Any]:
        """Trigger failover from failed region."""
        if not self.failover_manager:
            raise Exception("Failover manager not initialized")
            
        failover_start = time.time()
        
        try:
            # Execute failover procedure
            result = await self.failover_manager.execute_failover(
                failed_region, reason
            )
            
            # Update region status
            if failed_region in self.region_health:
                self.region_health[failed_region].status = RegionStatus.FAILOVER
                
            # Update performance metrics
            failover_time = (time.time() - failover_start) * 1000
            self.performance_metrics["failover_count"] += 1
            
            logging.warning(
                f"Regional failover completed for {failed_region.value} in {failover_time:.2f}ms"
            )
            
            return {
                "success": True,
                "failed_region": failed_region.value,
                "failover_time_ms": failover_time,
                "target_regions": result.get("target_regions", []),
                "affected_services": result.get("affected_services", []),
                "recovery_procedures": result.get("recovery_procedures", []),
                "timestamp": datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            failover_time = (time.time() - failover_start) * 1000
            logging.error(f"Regional failover failed: {str(e)}")
            
            return {
                "success": False,
                "failed_region": failed_region.value,
                "error": str(e),
                "failover_time_ms": failover_time,
                "timestamp": datetime.utcnow().isoformat()
            }
            
    async def get_global_status(self) -> Dict[str, Any]:
        """Get comprehensive global deployment status."""
        # Calculate global metrics
        healthy_regions = [
            region for region, health in self.region_health.items()
            if health.status == RegionStatus.HEALTHY
        ]
        
        total_capacity = sum(config.capacity for config in self.regions.values())
        available_capacity = sum(
            config.capacity for region, config in self.regions.items()
            if region in healthy_regions
        )
        
        # Get replication status
        replication_status = {}
        if self.data_replicator:
            replication_status = await self.data_replicator.get_replication_status()
            
        # Get load balancer status
        load_balancer_status = {}
        if self.global_load_balancer:
            load_balancer_status = await self.global_load_balancer.get_status()
            
        return {
            "global_health": {
                "healthy_regions": len(healthy_regions),
                "total_regions": len(self.regions),
                "availability_percentage": (len(healthy_regions) / len(self.regions)) * 100,
                "capacity_available": available_capacity,
                "capacity_total": total_capacity,
                "capacity_utilization": ((total_capacity - available_capacity) / total_capacity) * 100
            },
            "regional_status": {
                region.value: {
                    "status": health.status.value,
                    "response_time_ms": health.response_time_ms,
                    "error_rate": health.error_rate,
                    "capacity_utilization": health.capacity_utilization,
                    "services_healthy": health.services_healthy,
                    "last_check": health.last_check.isoformat()
                }
                for region, health in self.region_health.items()
            },
            "data_replication": replication_status,
            "load_balancing": load_balancer_status,
            "performance_metrics": self.performance_metrics,
            "traffic_routing": {
                "strategy": self.routing_strategy.value,
                "routes_count": sum(len(routes) for routes in self.traffic_routes.values()),
                "average_latency": self.performance_metrics.get("global_response_time", 0)
            },
            "last_updated": datetime.utcnow().isoformat()
        }
        
    async def update_routing_strategy(self, strategy: RoutingStrategy) -> bool:
        """Update global traffic routing strategy."""
        try:
            self.routing_strategy = strategy
            
            if self.global_load_balancer:
                await self.global_load_balancer.update_strategy(strategy)
                
            logging.info(f"Updated routing strategy to {strategy.value}")
            return True
            
        except Exception as e:
            logging.error(f"Failed to update routing strategy: {str(e)}")
            return False
            
    async def _get_region_health(self, region: Region) -> RegionHealth:
        """Get health status for a specific region."""
        return self.region_health.get(region, RegionHealth(
            region=region,
            status=RegionStatus.UNHEALTHY,
            response_time_ms=float('inf'),
            error_rate=1.0,
            capacity_utilization=1.0,
            last_check=datetime.utcnow(),
            services_healthy={}
        ))
        
    async def _execute_request_in_region(self, request: 'Request', 
                                       region: Region) -> Dict[str, Any]:
        """Execute request in specified region."""
        region_config = self.regions[region]
        
        # Select endpoint in region
        endpoint = await self._select_regional_endpoint(region, request)
        
        # Execute request
        # This would integrate with the regional service mesh/API gateway
        result = await self._make_regional_request(endpoint, request)
        
        return result
        
    async def _select_regional_endpoint(self, region: Region, 
                                      request: 'Request') -> str:
        """Select optimal endpoint within region."""
        config = self.regions[region]
        
        # For now, select first healthy endpoint
        # In production, this would use more sophisticated selection
        for endpoint in config.endpoints:
            # Check endpoint health
            if await self._check_endpoint_health(endpoint):
                return endpoint
                
        raise Exception(f"No healthy endpoints in region {region.value}")
        
    async def _make_regional_request(self, endpoint: str, 
                                   request: 'Request') -> Dict[str, Any]:
        """Make request to regional endpoint."""
        # This would implement the actual request execution
        # Placeholder implementation
        await asyncio.sleep(0.1)  # Simulate processing time
        
        return {
            "endpoint": endpoint,
            "status": "success",
            "data": "response_data"
        }
        
    async def _check_endpoint_health(self, endpoint: str) -> bool:
        """Check health of specific endpoint."""
        # This would implement actual health checking
        # Placeholder implementation
        return True
        
    async def _initialize_traffic_routes(self):
        """Initialize traffic routing tables."""
        # Calculate latency between all region pairs
        for source_region, source_config in self.regions.items():
            routes = []
            
            for target_region, target_config in self.regions.items():
                if source_region != target_region:
                    # Calculate estimated latency based on geographic distance
                    latency = await self._calculate_region_latency(
                        source_config.location, 
                        target_config.location
                    )
                    
                    route = TrafficRoute(
                        source_region=source_region.value,
                        target_region=target_region,
                        latency_ms=latency,
                        bandwidth_mbps=1000,  # Default bandwidth
                        routing_weight=1.0 / latency,  # Inverse latency weighting
                        last_updated=datetime.utcnow()
                    )
                    routes.append(route)
                    
            self.traffic_routes[source_region.value] = routes
            
    async def _calculate_region_latency(self, source_location: Dict[str, float], 
                                      target_location: Dict[str, float]) -> float:
        """Calculate estimated latency between regions based on location."""
        # Simplified geographic distance-based latency calculation
        # In production, this would use actual network measurements
        
        lat1, lon1 = source_location['lat'], source_location['lon']
        lat2, lon2 = target_location['lat'], target_location['lon']
        
        # Haversine formula for distance
        import math
        
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = (math.sin(dlat / 2) * math.sin(dlat / 2) +
             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
             math.sin(dlon / 2) * math.sin(dlon / 2))
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        distance_km = 6371 * c  # Earth's radius in km
        
        # Estimate latency: ~5ms per 1000km + base latency
        estimated_latency = (distance_km / 1000) * 5 + 10
        
        return estimated_latency
        
    async def _update_routing_metrics(self, region: Region, 
                                    response_time: float, success: bool):
        """Update routing performance metrics."""
        # Update region-specific metrics
        if region.value not in self.performance_metrics["regional_utilization"]:
            self.performance_metrics["regional_utilization"][region.value] = {
                "request_count": 0,
                "total_response_time": 0.0,
                "success_count": 0
            }
            
        metrics = self.performance_metrics["regional_utilization"][region.value]
        metrics["request_count"] += 1
        metrics["total_response_time"] += response_time
        
        if success:
            metrics["success_count"] += 1
            
        # Update global response time
        total_requests = sum(
            m["request_count"] for m in 
            self.performance_metrics["regional_utilization"].values()
        )
        total_response_time = sum(
            m["total_response_time"] for m in 
            self.performance_metrics["regional_utilization"].values()
        )
        
        if total_requests > 0:
            self.performance_metrics["global_response_time"] = total_response_time / total_requests
            
    async def _handle_routing_failure(self, request: 'Request', 
                                    error: str, response_time: float):
        """Handle routing failure and attempt recovery."""
        logging.error(f"Request routing failed: {error}")
        
        # Trigger health checks to update region status
        await self._trigger_emergency_health_checks()
        
        # Attempt automatic failover if possible
        healthy_regions = [
            region for region, health in self.region_health.items()
            if health.status == RegionStatus.HEALTHY
        ]
        
        if healthy_regions and self.failover_manager:
            await self.failover_manager.handle_routing_failure(request, healthy_regions)
            
    async def _trigger_emergency_health_checks(self):
        """Trigger immediate health checks across all regions."""
        tasks = []
        for region, monitor in self.health_monitors.items():
            tasks.append(monitor.emergency_health_check())
            
        await asyncio.gather(*tasks, return_exceptions=True)
        
    async def _health_monitoring_loop(self):
        """Background task for continuous health monitoring."""
        while True:
            try:
                # Update health for all regions
                for region, monitor in self.health_monitors.items():
                    health = await monitor.check_health()
                    self.region_health[region] = health
                    
                # Aggregate global health
                if self.global_health_aggregator:
                    await self.global_health_aggregator.update_global_health()
                    
                await asyncio.sleep(15)  # Health check every 15 seconds
                
            except Exception as e:
                logging.error(f"Health monitoring error: {str(e)}")
                await asyncio.sleep(5)  # Shorter retry interval on error
                
    async def _traffic_optimization_loop(self):
        """Background task for traffic routing optimization."""
        while True:
            try:
                # Update traffic routes based on current performance
                await self._optimize_traffic_routes()
                
                # Update load balancer weights
                if self.global_load_balancer:
                    await self.global_load_balancer.optimize_weights()
                    
                await asyncio.sleep(300)  # Optimize every 5 minutes
                
            except Exception as e:
                logging.error(f"Traffic optimization error: {str(e)}")
                await asyncio.sleep(60)
                
    async def _replication_monitoring_loop(self):
        """Background task for data replication monitoring."""
        while True:
            try:
                if self.data_replicator:
                    # Check replication health and lag
                    replication_status = await self.data_replicator.monitor_replication()
                    
                    # Update replication metrics
                    for region, lag in replication_status.get("lag_by_region", {}).items():
                        self.performance_metrics["replication_lag"][region] = lag
                        
                await asyncio.sleep(60)  # Monitor replication every minute
                
            except Exception as e:
                logging.error(f"Replication monitoring error: {str(e)}")
                await asyncio.sleep(30)
                
    async def _performance_collection_loop(self):
        """Background task for performance metrics collection."""
        while True:
            try:
                # Collect performance metrics from all regions
                await self._collect_performance_metrics()
                
                await asyncio.sleep(60)  # Collect every minute
                
            except Exception as e:
                logging.error(f"Performance collection error: {str(e)}")
                await asyncio.sleep(30)
                
    async def _optimize_traffic_routes(self):
        """Optimize traffic routes based on current performance."""
        # Update route weights based on current latency and health
        for source_region, routes in self.traffic_routes.items():
            for route in routes:
                # Get current health for target region
                target_health = await self._get_region_health(route.target_region)
                
                # Adjust routing weight based on health and performance
                if target_health.status == RegionStatus.HEALTHY:
                    # Weight based on response time and capacity
                    performance_factor = 1.0 / max(target_health.response_time_ms, 1)
                    capacity_factor = 1.0 - target_health.capacity_utilization
                    route.routing_weight = performance_factor * capacity_factor
                else:
                    # Unhealthy regions get zero weight
                    route.routing_weight = 0.0
                    
                route.last_updated = datetime.utcnow()
                
    async def _collect_performance_metrics(self):
        """Collect and aggregate performance metrics."""
        # Collect metrics from all regions
        for region, health in self.region_health.items():
            region_key = region.value
            
            # Update cross-region latency metrics
            if region_key not in self.performance_metrics["cross_region_latency"]:
                self.performance_metrics["cross_region_latency"][region_key] = {}
                
            for other_region in self.regions:
                if other_region != region:
                    # Get latency from traffic routes
                    routes = self.traffic_routes.get(region_key, [])
                    for route in routes:
                        if route.target_region == other_region:
                            self.performance_metrics["cross_region_latency"][region_key][other_region.value] = route.latency_ms
                            break
```

2. **Global Load Balancer** (`app/infrastructure/global_load_balancer.py`):
```python
from typing import Dict, Any, List, Optional, Callable, Awaitable
import asyncio
import time
import logging
import random
import ipaddress
from dataclasses import dataclass
from enum import Enum
import geoip2.database
import geoip2.errors

class LoadBalancingAlgorithm(Enum):
    ROUND_ROBIN = "round_robin"
    WEIGHTED_ROUND_ROBIN = "weighted_round_robin"
    LEAST_CONNECTIONS = "least_connections"
    LEAST_RESPONSE_TIME = "least_response_time"
    GEOGRAPHIC = "geographic"
    IP_HASH = "ip_hash"

@dataclass
class RegionWeight:
    region: Region
    weight: float
    current_connections: int
    total_requests: int
    average_response_time: float
    last_updated: datetime

class GlobalLoadBalancer:
    """Global load balancer with intelligent traffic routing."""
    
    def __init__(self, regions: Dict[Region, RegionConfig], 
                 health_provider: Callable[[Region], Awaitable[RegionHealth]],
                 routing_strategy: RoutingStrategy):
        self.regions = regions
        self.health_provider = health_provider
        self.routing_strategy = routing_strategy
        
        # Load balancing state
        self.region_weights: Dict[Region, RegionWeight] = {}
        self.algorithm = LoadBalancingAlgorithm.LEAST_RESPONSE_TIME
        self.round_robin_index = 0
        
        # Geographic routing
        self.geoip_reader: Optional[geoip2.database.Reader] = None
        self.geographic_preferences: Dict[str, List[Region]] = {}
        
        # Connection tracking
        self.active_connections: Dict[Region, int] = {}
        self.connection_history: List[Dict[str, Any]] = []
        
        # Performance metrics
        self.routing_metrics = {
            "total_requests": 0,
            "routing_decisions": {},
            "algorithm_performance": {},
            "geographic_accuracy": 0.0
        }
        
        # Initialize load balancer
        asyncio.create_task(self._initialize_load_balancer())
        
    async def _initialize_load_balancer(self):
        """Initialize global load balancer."""
        # Initialize region weights
        for region in self.regions:
            self.region_weights[region] = RegionWeight(
                region=region,
                weight=1.0,
                current_connections=0,
                total_requests=0,
                average_response_time=0.0,
                last_updated=datetime.utcnow()
            )
            self.active_connections[region] = 0
            
        # Initialize geographic database
        try:
            # In production, this would use actual GeoIP database
            self.geoip_reader = self._create_mock_geoip_reader()
            self._initialize_geographic_preferences()
        except Exception as e:
            logging.warning(f"GeoIP initialization failed: {str(e)}")
            
        # Start background optimization
        asyncio.create_task(self._weight_optimization_loop())
        
    async def select_region(self, request: 'Request', 
                          client_location: Optional[Dict[str, float]] = None) -> Optional[Region]:
        """Select optimal region for request."""
        start_time = time.time()
        
        try:
            # Get healthy regions
            healthy_regions = await self._get_healthy_regions()
            
            if not healthy_regions:
                return None
                
            # Apply routing strategy
            if self.routing_strategy == RoutingStrategy.GEOGRAPHIC:
                selected_region = await self._select_by_geography(request, healthy_regions, client_location)
            elif self.routing_strategy == RoutingStrategy.LATENCY:
                selected_region = await self._select_by_latency(request, healthy_regions, client_location)
            elif self.routing_strategy == RoutingStrategy.WEIGHTED:
                selected_region = await self._select_by_weight(healthy_regions)
            elif self.routing_strategy == RoutingStrategy.HEALTH_BASED:
                selected_region = await self._select_by_health(healthy_regions)
            else:
                selected_region = await self._select_round_robin(healthy_regions)
                
            # Update routing metrics
            if selected_region:
                await self._update_routing_metrics(selected_region, request)
                
            routing_time = (time.time() - start_time) * 1000
            
            logging.debug(
                f"Region selection completed in {routing_time:.2f}ms: {selected_region.value if selected_region else 'none'}"
            )
            
            return selected_region
            
        except Exception as e:
            logging.error(f"Region selection failed: {str(e)}")
            # Fallback to first healthy region
            healthy_regions = await self._get_healthy_regions()
            return healthy_regions[0] if healthy_regions else None
            
    async def update_strategy(self, strategy: RoutingStrategy):
        """Update routing strategy."""
        self.routing_strategy = strategy
        logging.info(f"Updated load balancer routing strategy to {strategy.value}")
        
    async def optimize_weights(self):
        """Optimize region weights based on performance."""
        for region in self.regions:
            try:
                health = await self.health_provider(region)
                weight = self.region_weights[region]
                
                # Calculate new weight based on performance metrics
                performance_factor = 1.0 / max(health.response_time_ms, 1)
                capacity_factor = 1.0 - health.capacity_utilization
                health_factor = 1.0 if health.status == RegionStatus.HEALTHY else 0.0
                
                new_weight = performance_factor * capacity_factor * health_factor
                
                # Apply smoothing to prevent rapid weight changes
                alpha = 0.3  # Smoothing factor
                weight.weight = alpha * new_weight + (1 - alpha) * weight.weight
                weight.last_updated = datetime.utcnow()
                
            except Exception as e:
                logging.error(f"Weight optimization failed for {region.value}: {str(e)}")
                
    async def get_status(self) -> Dict[str, Any]:
        """Get load balancer status."""
        return {
            "routing_strategy": self.routing_strategy.value,
            "algorithm": self.algorithm.value,
            "region_weights": {
                region.value: {
                    "weight": weight.weight,
                    "connections": weight.current_connections,
                    "requests": weight.total_requests,
                    "response_time": weight.average_response_time
                }
                for region, weight in self.region_weights.items()
            },
            "routing_metrics": self.routing_metrics,
            "geographic_enabled": self.geoip_reader is not None,
            "healthy_regions": len(await self._get_healthy_regions()),
            "total_regions": len(self.regions)
        }
        
    async def _get_healthy_regions(self) -> List[Region]:
        """Get list of healthy regions."""
        healthy_regions = []
        
        for region in self.regions:
            health = await self.health_provider(region)
            if health.status in [RegionStatus.HEALTHY, RegionStatus.DEGRADED]:
                healthy_regions.append(region)
                
        return healthy_regions
        
    async def _select_by_geography(self, request: 'Request', 
                                 healthy_regions: List[Region],
                                 client_location: Optional[Dict[str, float]] = None) -> Optional[Region]:
        """Select region based on geographic proximity."""
        if not client_location:
            # Try to determine location from IP
            client_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
            client_location = await self._get_location_from_ip(client_ip)
            
        if not client_location:
            # Fallback to latency-based selection
            return await self._select_by_latency(request, healthy_regions, None)
            
        # Find closest region
        closest_region = None
        min_distance = float('inf')
        
        for region in healthy_regions:
            region_config = self.regions[region]
            distance = await self._calculate_geographic_distance(
                client_location, region_config.location
            )
            
            if distance < min_distance:
                min_distance = distance
                closest_region = region
                
        return closest_region
        
    async def _select_by_latency(self, request: 'Request', 
                               healthy_regions: List[Region],
                               client_location: Optional[Dict[str, float]] = None) -> Optional[Region]:
        """Select region based on expected latency."""
        best_region = None
        min_latency = float('inf')
        
        for region in healthy_regions:
            health = await self.health_provider(region)
            
            # Use actual response time as latency estimate
            estimated_latency = health.response_time_ms
            
            # Adjust for capacity utilization
            capacity_penalty = health.capacity_utilization * 50  # Up to 50ms penalty
            total_latency = estimated_latency + capacity_penalty
            
            if total_latency < min_latency:
                min_latency = total_latency
                best_region = region
                
        return best_region
        
    async def _select_by_weight(self, healthy_regions: List[Region]) -> Optional[Region]:
        """Select region based on weighted random selection."""
        if not healthy_regions:
            return None
            
        # Calculate total weight
        total_weight = sum(
            self.region_weights[region].weight for region in healthy_regions
        )
        
        if total_weight <= 0:
            return random.choice(healthy_regions)
            
        # Weighted random selection
        rand_value = random.uniform(0, total_weight)
        cumulative_weight = 0
        
        for region in healthy_regions:
            cumulative_weight += self.region_weights[region].weight
            if rand_value <= cumulative_weight:
                return region
                
        return healthy_regions[-1]  # Fallback
        
    async def _select_by_health(self, healthy_regions: List[Region]) -> Optional[Region]:
        """Select region with best health metrics."""
        best_region = None
        best_score = -1
        
        for region in healthy_regions:
            health = await self.health_provider(region)
            
            # Calculate health score (higher is better)
            response_time_score = max(0, 1000 - health.response_time_ms) / 1000
            error_rate_score = 1.0 - health.error_rate
            capacity_score = 1.0 - health.capacity_utilization
            
            health_score = (response_time_score + error_rate_score + capacity_score) / 3
            
            if health_score > best_score:
                best_score = health_score
                best_region = region
                
        return best_region
        
    async def _select_round_robin(self, healthy_regions: List[Region]) -> Optional[Region]:
        """Select region using round-robin algorithm."""
        if not healthy_regions:
            return None
            
        # Simple round-robin selection
        selected_region = healthy_regions[self.round_robin_index % len(healthy_regions)]
        self.round_robin_index += 1
        
        return selected_region
        
    async def _get_location_from_ip(self, ip_address: str) -> Optional[Dict[str, float]]:
        """Get geographic location from IP address."""
        if not self.geoip_reader:
            return None
            
        try:
            # Parse IP address
            ip = ipaddress.ip_address(ip_address)
            
            # Skip private/local addresses
            if ip.is_private or ip.is_loopback:
                return None
                
            # Mock implementation - in production use actual GeoIP lookup
            response = self.geoip_reader.city(ip_address)
            
            return {
                "lat": float(response.location.latitude),
                "lon": float(response.location.longitude)
            }
            
        except Exception as e:
            logging.debug(f"GeoIP lookup failed for {ip_address}: {str(e)}")
            return None
            
    async def _calculate_geographic_distance(self, location1: Dict[str, float], 
                                           location2: Dict[str, float]) -> float:
        """Calculate geographic distance between two points."""
        import math
        
        lat1, lon1 = math.radians(location1['lat']), math.radians(location1['lon'])
        lat2, lon2 = math.radians(location2['lat']), math.radians(location2['lon'])
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = (math.sin(dlat / 2) ** 2 + 
             math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        
        return 6371 * c  # Earth's radius in km
        
    async def _update_routing_metrics(self, selected_region: Region, request: 'Request'):
        """Update routing performance metrics."""
        self.routing_metrics["total_requests"] += 1
        
        # Update region-specific metrics
        region_key = selected_region.value
        if region_key not in self.routing_metrics["routing_decisions"]:
            self.routing_metrics["routing_decisions"][region_key] = 0
            
        self.routing_metrics["routing_decisions"][region_key] += 1
        
        # Update region weight metrics
        weight = self.region_weights[selected_region]
        weight.total_requests += 1
        weight.current_connections += 1
        
    def _create_mock_geoip_reader(self):
        """Create mock GeoIP reader for testing."""
        # In production, this would initialize actual GeoIP database
        class MockGeoIPReader:
            def city(self, ip_address):
                # Mock response based on IP patterns
                class MockLocation:
                    def __init__(self, lat, lon):
                        self.latitude = lat
                        self.longitude = lon
                        
                class MockResponse:
                    def __init__(self, lat, lon):
                        self.location = MockLocation(lat, lon)
                        
                # Simple IP-based location mapping for testing
                if ip_address.startswith('192.168'):
                    return MockResponse(37.7749, -122.4194)  # San Francisco
                elif ip_address.startswith('10.'):
                    return MockResponse(51.5074, -0.1278)    # London
                else:
                    return MockResponse(35.6762, 139.6503)   # Tokyo
                    
        return MockGeoIPReader()
        
    def _initialize_geographic_preferences(self):
        """Initialize geographic routing preferences."""
        # Define regional preferences based on geography
        self.geographic_preferences = {
            "north_america": [Region.US_EAST_1, Region.US_WEST_2],
            "europe": [Region.EU_WEST_1, Region.EU_CENTRAL_1],
            "asia_pacific": [Region.ASIA_PACIFIC_1, Region.ASIA_PACIFIC_2]
        }
        
    async def _weight_optimization_loop(self):
        """Background task for continuous weight optimization."""
        while True:
            try:
                await self.optimize_weights()
                await asyncio.sleep(60)  # Optimize every minute
                
            except Exception as e:
                logging.error(f"Weight optimization error: {str(e)}")
                await asyncio.sleep(30)
```

## Dependencies
- Task 051: High-Performance System Architecture Implementation
- Task 008: Async Database Operations  
- Task 025: Redis Integration
- Task 043: Real-time Performance Monitoring System
- Kubernetes multi-cluster management tools
- Cloud provider multi-region services (AWS, GCP, Azure)
- Global CDN services (CloudFlare, AWS CloudFront)
- DNS management and geo-routing services
- Cross-region networking and VPN solutions

## Estimated Time
45-55 hours

## Required Skills
- Multi-region cloud architecture design
- Global load balancing and traffic management
- Cross-region data replication strategies
- DNS and CDN configuration
- Network latency optimization
- Disaster recovery planning and implementation
- Kubernetes multi-cluster management
- Geographic routing and location services
- High availability system design