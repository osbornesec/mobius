# Task 053: Enterprise SSO and Advanced Authentication System

## Overview
Implement a comprehensive enterprise Single Sign-On (SSO) and advanced authentication system that supports multiple identity providers, multi-factor authentication, and enterprise-grade security features. This system will provide seamless authentication integration for enterprise customers while maintaining the highest security standards and compliance requirements.

## Success Criteria
- [ ] SSO integration supports major identity providers (SAML 2.0, OpenID Connect, OAuth 2.0)
- [ ] Multi-factor authentication (MFA) implementation with 95%+ reliability
- [ ] Enterprise directory integration (Active Directory, LDAP, Azure AD)
- [ ] Session management with configurable timeouts and security policies
- [ ] Role-based access control (RBAC) with fine-grained permissions
- [ ] Compliance with SOC 2, GDPR, and enterprise security standards

## Test First Approach

### Tests to Write BEFORE Implementation:

1. **SSO Integration Tests** (`tests/backend/integration/test_sso_integration.py`):
```python
def test_saml_authentication():
    """Test SAML 2.0 authentication flow."""
    # Test SAML request generation
    # Test SAML response validation
    # Test user provisioning from SAML attributes
    # Test SAML encryption and signing
    # Test SAML session management

def test_oidc_authentication():
    """Test OpenID Connect authentication flow."""
    # Test OIDC authorization code flow
    # Test ID token validation
    # Test userinfo endpoint integration
    # Test PKCE support
    # Test refresh token handling

def test_oauth2_authentication():
    """Test OAuth 2.0 authentication flow."""
    # Test authorization code flow
    # Test implicit flow (if needed)
    # Test client credentials flow
    # Test token validation and refresh
    # Test scope-based authorization
```

2. **MFA Implementation Tests** (`tests/backend/unit/test_mfa.py`):
```python
def test_totp_authentication():
    """Test Time-based One-Time Password authentication."""
    # Test TOTP generation and validation
    # Test QR code generation for setup
    # Test backup codes generation
    # Test time window validation
    # Test rate limiting for failed attempts

def test_sms_authentication():
    """Test SMS-based authentication."""
    # Test SMS code generation and delivery
    # Test code validation within time window
    # Test rate limiting for SMS requests
    # Test fallback mechanisms
    # Test international phone number support

def test_email_authentication():
    """Test email-based authentication."""
    # Test email code generation and delivery
    # Test secure email templates
    # Test code validation
    # Test email verification workflow
    # Test anti-phishing measures
```

3. **Enterprise Directory Tests** (`tests/backend/unit/test_enterprise_directory.py`):
```python
def test_active_directory_integration():
    """Test Active Directory integration."""
    # Test LDAP connection and authentication
    # Test user and group synchronization
    # Test attribute mapping
    # Test nested group support
    # Test connection failover

def test_azure_ad_integration():
    """Test Azure Active Directory integration."""
    # Test Azure AD Graph API integration
    # Test user provisioning and deprovisioning
    # Test group membership synchronization
    # Test conditional access policies
    # Test B2B user support

def test_user_provisioning():
    """Test automatic user provisioning."""
    # Test just-in-time provisioning
    # Test user attribute updates
    # Test deprovisioning workflows
    # Test role assignment automation
    # Test audit trail generation
```

## Implementation Details

1. **Enterprise SSO Core System** (`app/auth/enterprise_sso.py`):
```python
from typing import Dict, Any, List, Optional, Set, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import asyncio
import json
import logging
import hashlib
import secrets
import base64
import jwt
from abc import ABC, abstractmethod
import xml.etree.ElementTree as ET
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
import requests
import aiohttp
from urllib.parse import urlencode, parse_qs

class IdentityProvider(Enum):
    SAML2 = "saml2"
    OIDC = "oidc"
    OAUTH2 = "oauth2"
    LDAP = "ldap"
    AZURE_AD = "azure_ad"
    OKTA = "okta"
    PING_IDENTITY = "ping_identity"
    ONELOGIN = "onelogin"

class AuthenticationMethod(Enum):
    PASSWORD = "password"
    TOTP = "totp"
    SMS = "sms"
    EMAIL = "email"
    PUSH_NOTIFICATION = "push"
    BIOMETRIC = "biometric"
    HARDWARE_TOKEN = "hardware_token"

class SessionStatus(Enum):
    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"
    SUSPENDED = "suspended"

@dataclass
class IdentityProviderConfig:
    provider_type: IdentityProvider
    name: str
    enabled: bool
    config: Dict[str, Any]
    priority: int
    auto_provisioning: bool = True
    attribute_mapping: Dict[str, str] = field(default_factory=dict)
    group_mapping: Dict[str, str] = field(default_factory=dict)

@dataclass
class AuthenticationContext:
    user_id: str
    session_id: str
    ip_address: str
    user_agent: str
    timestamp: datetime
    provider: IdentityProvider
    authentication_methods: List[AuthenticationMethod]
    risk_score: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class EnterpriseUser:
    user_id: str
    username: str
    email: str
    display_name: str
    groups: List[str]
    roles: List[str]
    attributes: Dict[str, Any]
    provider: IdentityProvider
    provisioned_at: datetime
    last_sync: datetime
    is_active: bool = True

@dataclass
class UserSession:
    session_id: str
    user_id: str
    created_at: datetime
    last_activity: datetime
    expires_at: datetime
    status: SessionStatus
    authentication_context: AuthenticationContext
    permissions: Set[str] = field(default_factory=set)
    metadata: Dict[str, Any] = field(default_factory=dict)

class EnterpriseSSO:
    def __init__(self):
        self.identity_providers: Dict[str, IdentityProviderConfig] = {}
        self.authentication_handlers: Dict[IdentityProvider, 'BaseAuthenticationHandler'] = {}
        self.session_manager: Optional['SessionManager'] = None
        self.user_provisioner: Optional['UserProvisioner'] = None
        self.mfa_manager: Optional['MFAManager'] = None

        # Security configuration
        self.security_config = {
            "session_timeout_minutes": 480,  # 8 hours
            "max_concurrent_sessions": 5,
            "password_policy": {
                "min_length": 12,
                "require_uppercase": True,
                "require_lowercase": True,
                "require_numbers": True,
                "require_special_chars": True,
                "password_history": 12
            },
            "mfa_required": True,
            "risk_based_auth": True,
            "audit_logging": True
        }

        # Active sessions and users
        self.active_sessions: Dict[str, UserSession] = {}
        self.enterprise_users: Dict[str, EnterpriseUser] = {}

        # Metrics and monitoring
        self.auth_metrics = {
            "total_authentications": 0,
            "successful_authentications": 0,
            "failed_authentications": 0,
            "mfa_challenges": 0,
            "sso_authentications": 0,
            "active_sessions": 0
        }

        # Initialize components
        asyncio.create_task(self._initialize_enterprise_sso())

    async def _initialize_enterprise_sso(self):
        """Initialize enterprise SSO system."""
        # Initialize session manager
        self.session_manager = SessionManager(
            timeout_minutes=self.security_config["session_timeout_minutes"],
            max_concurrent=self.security_config["max_concurrent_sessions"]
        )

        # Initialize user provisioner
        self.user_provisioner = UserProvisioner(
            enterprise_users=self.enterprise_users
        )

        # Initialize MFA manager
        self.mfa_manager = MFAManager(
            required=self.security_config["mfa_required"]
        )

        # Initialize authentication handlers
        self.authentication_handlers = {
            IdentityProvider.SAML2: SAML2Handler(),
            IdentityProvider.OIDC: OIDCHandler(),
            IdentityProvider.OAUTH2: OAuth2Handler(),
            IdentityProvider.AZURE_AD: AzureADHandler(),
            IdentityProvider.LDAP: LDAPHandler()
        }

        # Load identity provider configurations
        await self._load_identity_providers()

        # Start background tasks
        asyncio.create_task(self._session_cleanup_loop())
        asyncio.create_task(self._user_sync_loop())
        asyncio.create_task(self._metrics_collection_loop())

        logging.info("Enterprise SSO system initialized")

    async def authenticate_user(self, provider_name: str,
                              authentication_data: Dict[str, Any],
                              context: Dict[str, Any]) -> Dict[str, Any]:
        """Authenticate user through specified identity provider."""
        start_time = datetime.utcnow()

        try:
            # Get identity provider configuration
            if provider_name not in self.identity_providers:
                raise ValueError(f"Identity provider {provider_name} not configured")

            provider_config = self.identity_providers[provider_name]

            if not provider_config.enabled:
                raise ValueError(f"Identity provider {provider_name} is disabled")

            # Get authentication handler
            handler = self.authentication_handlers.get(provider_config.provider_type)
            if not handler:
                raise ValueError(f"No handler for provider type {provider_config.provider_type.value}")

            # Perform authentication
            auth_result = await handler.authenticate(
                provider_config, authentication_data, context
            )

            if not auth_result.get("success", False):
                self.auth_metrics["failed_authentications"] += 1
                return {
                    "success": False,
                    "error": auth_result.get("error", "Authentication failed"),
                    "timestamp": start_time.isoformat()
                }

            # Extract user information
            user_info = auth_result["user_info"]

            # Provision or update user
            user = await self.user_provisioner.provision_user(
                user_info, provider_config
            )

            # Create authentication context
            auth_context = AuthenticationContext(
                user_id=user.user_id,
                session_id=secrets.token_urlsafe(32),
                ip_address=context.get("ip_address", "unknown"),
                user_agent=context.get("user_agent", "unknown"),
                timestamp=start_time,
                provider=provider_config.provider_type,
                authentication_methods=[AuthenticationMethod.PASSWORD],  # Will be updated with MFA
                metadata=context
            )

            # Check if MFA is required
            mfa_required = await self._is_mfa_required(user, auth_context)

            if mfa_required:
                # Initiate MFA challenge
                mfa_challenge = await self.mfa_manager.initiate_challenge(
                    user.user_id, auth_context
                )

                self.auth_metrics["mfa_challenges"] += 1

                return {
                    "success": True,
                    "mfa_required": True,
                    "mfa_challenge": mfa_challenge,
                    "session_id": auth_context.session_id,
                    "timestamp": start_time.isoformat()
                }
            else:
                # Create session without MFA
                session = await self._create_user_session(user, auth_context)

                self.auth_metrics["successful_authentications"] += 1
                self.auth_metrics["sso_authentications"] += 1

                return {
                    "success": True,
                    "mfa_required": False,
                    "session": self._serialize_session(session),
                    "user": self._serialize_user(user),
                    "timestamp": start_time.isoformat()
                }

        except Exception as e:
            self.auth_metrics["failed_authentications"] += 1
            logging.error(f"Authentication failed: {str(e)}")

            return {
                "success": False,
                "error": str(e),
                "timestamp": start_time.isoformat()
            }
        finally:
            self.auth_metrics["total_authentications"] += 1

    async def complete_mfa_authentication(self, session_id: str,
                                        mfa_code: str,
                                        method: AuthenticationMethod) -> Dict[str, Any]:
        """Complete MFA authentication process."""
        try:
            # Verify MFA code
            verification_result = await self.mfa_manager.verify_code(
                session_id, mfa_code, method
            )

            if not verification_result.get("success", False):
                return {
                    "success": False,
                    "error": "Invalid MFA code"
                }

            # Get user and create session
            user_id = verification_result["user_id"]
            user = self.enterprise_users.get(user_id)

            if not user:
                return {
                    "success": False,
                    "error": "User not found"
                }

            # Create authentication context with MFA
            auth_context = AuthenticationContext(
                user_id=user_id,
                session_id=session_id,
                ip_address=verification_result.get("ip_address", "unknown"),
                user_agent=verification_result.get("user_agent", "unknown"),
                timestamp=datetime.utcnow(),
                provider=user.provider,
                authentication_methods=[AuthenticationMethod.PASSWORD, method]
            )

            # Create session
            session = await self._create_user_session(user, auth_context)

            self.auth_metrics["successful_authentications"] += 1

            return {
                "success": True,
                "session": self._serialize_session(session),
                "user": self._serialize_user(user),
                "timestamp": datetime.utcnow().isoformat()
            }

        except Exception as e:
            logging.error(f"MFA authentication failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def validate_session(self, session_id: str) -> Dict[str, Any]:
        """Validate user session."""
        try:
            session = self.active_sessions.get(session_id)

            if not session:
                return {
                    "valid": False,
                    "error": "Session not found"
                }

            # Check session expiration
            if datetime.utcnow() > session.expires_at:
                await self._revoke_session(session_id, "expired")
                return {
                    "valid": False,
                    "error": "Session expired"
                }

            # Check session status
            if session.status != SessionStatus.ACTIVE:
                return {
                    "valid": False,
                    "error": f"Session {session.status.value}"
                }

            # Update last activity
            session.last_activity = datetime.utcnow()

            # Get user information
            user = self.enterprise_users.get(session.user_id)

            return {
                "valid": True,
                "session": self._serialize_session(session),
                "user": self._serialize_user(user) if user else None,
                "permissions": list(session.permissions)
            }

        except Exception as e:
            logging.error(f"Session validation failed: {str(e)}")
            return {
                "valid": False,
                "error": str(e)
            }

    async def revoke_session(self, session_id: str, reason: str = "manual") -> bool:
        """Revoke user session."""
        return await self._revoke_session(session_id, reason)

    async def get_user_sessions(self, user_id: str) -> List[Dict[str, Any]]:
        """Get all active sessions for a user."""
        user_sessions = [
            self._serialize_session(session)
            for session in self.active_sessions.values()
            if session.user_id == user_id and session.status == SessionStatus.ACTIVE
        ]

        return user_sessions

    async def configure_identity_provider(self, provider_config: IdentityProviderConfig) -> bool:
        """Configure or update identity provider."""
        try:
            # Validate configuration
            await self._validate_provider_config(provider_config)

            # Store configuration
            self.identity_providers[provider_config.name] = provider_config

            logging.info(f"Identity provider {provider_config.name} configured")
            return True

        except Exception as e:
            logging.error(f"Failed to configure identity provider: {str(e)}")
            return False

    async def get_authentication_status(self) -> Dict[str, Any]:
        """Get comprehensive authentication system status."""
        # Calculate session statistics
        active_sessions_count = len([
            s for s in self.active_sessions.values()
            if s.status == SessionStatus.ACTIVE
        ])

        # Calculate user statistics
        total_users = len(self.enterprise_users)
        active_users = len([
            u for u in self.enterprise_users.values()
            if u.is_active
        ])

        # Calculate provider statistics
        enabled_providers = len([
            p for p in self.identity_providers.values()
            if p.enabled
        ])

        return {
            "system_status": {
                "enabled_providers": enabled_providers,
                "total_providers": len(self.identity_providers),
                "mfa_enabled": self.security_config["mfa_required"],
                "risk_based_auth": self.security_config["risk_based_auth"]
            },
            "user_statistics": {
                "total_users": total_users,
                "active_users": active_users,
                "active_sessions": active_sessions_count,
                "max_concurrent_sessions": self.security_config["max_concurrent_sessions"]
            },
            "authentication_metrics": self.auth_metrics,
            "session_statistics": {
                "active_sessions": active_sessions_count,
                "session_timeout_minutes": self.security_config["session_timeout_minutes"],
                "average_session_duration": await self._calculate_average_session_duration()
            },
            "security_metrics": {
                "mfa_adoption_rate": await self._calculate_mfa_adoption_rate(),
                "risk_score_distribution": await self._calculate_risk_score_distribution(),
                "failed_auth_rate": (
                    self.auth_metrics["failed_authentications"] /
                    max(1, self.auth_metrics["total_authentications"])
                )
            },
            "provider_status": {
                name: {
                    "enabled": config.enabled,
                    "type": config.provider_type.value,
                    "auto_provisioning": config.auto_provisioning,
                    "priority": config.priority
                }
                for name, config in self.identity_providers.items()
            },
            "last_updated": datetime.utcnow().isoformat()
        }

    async def _load_identity_providers(self):
        """Load identity provider configurations."""
        # This would typically load from database or configuration files
        # For now, we'll set up some example configurations

        # Example SAML provider
        saml_config = IdentityProviderConfig(
            provider_type=IdentityProvider.SAML2,
            name="corporate_saml",
            enabled=True,
            config={
                "entity_id": "https://mobius.example.com/saml/metadata",
                "sso_url": "https://idp.example.com/saml/sso",
                "certificate": "-----BEGIN CERTIFICATE-----...",
                "sign_requests": True,
                "encrypt_assertions": True
            },
            priority=1,
            attribute_mapping={
                "email": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
                "first_name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
                "last_name": "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname"
            }
        )

        # Example Azure AD provider
        azure_config = IdentityProviderConfig(
            provider_type=IdentityProvider.AZURE_AD,
            name="azure_ad",
            enabled=True,
            config={
                "tenant_id": "your-tenant-id",
                "client_id": "your-client-id",
                "client_secret": "your-client-secret",
                "authority": "https://login.microsoftonline.com/your-tenant-id"
            },
            priority=2,
            attribute_mapping={
                "email": "mail",
                "first_name": "givenName",
                "last_name": "surname",
                "groups": "groups"
            }
        )

        self.identity_providers["corporate_saml"] = saml_config
        self.identity_providers["azure_ad"] = azure_config

    async def _is_mfa_required(self, user: EnterpriseUser,
                             context: AuthenticationContext) -> bool:
        """Determine if MFA is required for authentication."""
        # Check global MFA requirement
        if self.security_config["mfa_required"]:
            return True

        # Check risk-based authentication
        if self.security_config["risk_based_auth"]:
            risk_score = await self._calculate_risk_score(user, context)
            return risk_score > 0.5  # High risk requires MFA

        return False

    async def _calculate_risk_score(self, user: EnterpriseUser,
                                  context: AuthenticationContext) -> float:
        """Calculate authentication risk score."""
        risk_factors = []

        # Check for unusual IP address
        user_ips = await self._get_user_ip_history(user.user_id)
        if context.ip_address not in user_ips:
            risk_factors.append(0.3)

        # Check for unusual user agent
        user_agents = await self._get_user_agent_history(user.user_id)
        if context.user_agent not in user_agents:
            risk_factors.append(0.2)

        # Check time of access
        if context.timestamp.hour < 6 or context.timestamp.hour > 22:
            risk_factors.append(0.1)

        # Calculate overall risk score
        return min(1.0, sum(risk_factors))

    async def _create_user_session(self, user: EnterpriseUser,
                                 context: AuthenticationContext) -> UserSession:
        """Create new user session."""
        # Calculate session expiration
        expires_at = datetime.utcnow() + timedelta(
            minutes=self.security_config["session_timeout_minutes"]
        )

        # Get user permissions
        permissions = await self._get_user_permissions(user)

        # Create session
        session = UserSession(
            session_id=context.session_id,
            user_id=user.user_id,
            created_at=context.timestamp,
            last_activity=context.timestamp,
            expires_at=expires_at,
            status=SessionStatus.ACTIVE,
            authentication_context=context,
            permissions=permissions
        )

        # Store session
        self.active_sessions[session.session_id] = session
        self.auth_metrics["active_sessions"] += 1

        # Check concurrent session limit
        await self._enforce_session_limits(user.user_id)

        return session

    async def _get_user_permissions(self, user: EnterpriseUser) -> Set[str]:
        """Get user permissions based on roles and groups."""
        permissions = set()

        # Add role-based permissions
        for role in user.roles:
            role_permissions = await self._get_role_permissions(role)
            permissions.update(role_permissions)

        # Add group-based permissions
        for group in user.groups:
            group_permissions = await self._get_group_permissions(group)
            permissions.update(group_permissions)

        return permissions

    async def _get_role_permissions(self, role: str) -> Set[str]:
        """Get permissions for a specific role."""
        # This would typically query a role-permission mapping
        role_permissions = {
            "admin": {"read", "write", "delete", "admin"},
            "user": {"read", "write"},
            "viewer": {"read"}
        }

        return set(role_permissions.get(role, []))

    async def _get_group_permissions(self, group: str) -> Set[str]:
        """Get permissions for a specific group."""
        # This would typically query a group-permission mapping
        # For now, return empty set
        return set()

    async def _enforce_session_limits(self, user_id: str):
        """Enforce concurrent session limits for user."""
        user_sessions = [
            session for session in self.active_sessions.values()
            if session.user_id == user_id and session.status == SessionStatus.ACTIVE
        ]

        if len(user_sessions) > self.security_config["max_concurrent_sessions"]:
            # Revoke oldest sessions
            user_sessions.sort(key=lambda s: s.created_at)
            sessions_to_revoke = user_sessions[:-self.security_config["max_concurrent_sessions"]]

            for session in sessions_to_revoke:
                await self._revoke_session(session.session_id, "session_limit_exceeded")

    async def _revoke_session(self, session_id: str, reason: str) -> bool:
        """Revoke a user session."""
        try:
            session = self.active_sessions.get(session_id)
            if session:
                session.status = SessionStatus.REVOKED
                session.metadata["revocation_reason"] = reason
                session.metadata["revoked_at"] = datetime.utcnow().isoformat()

                if session.status == SessionStatus.ACTIVE:
                    self.auth_metrics["active_sessions"] -= 1

                logging.info(f"Session {session_id} revoked: {reason}")
                return True

            return False

        except Exception as e:
            logging.error(f"Failed to revoke session: {str(e)}")
            return False

    async def _validate_provider_config(self, config: IdentityProviderConfig):
        """Validate identity provider configuration."""
        if not config.name:
            raise ValueError("Provider name is required")

        if not config.config:
            raise ValueError("Provider configuration is required")

        # Type-specific validation
        if config.provider_type == IdentityProvider.SAML2:
            required_fields = ["entity_id", "sso_url", "certificate"]
            for field in required_fields:
                if field not in config.config:
                    raise ValueError(f"SAML2 provider missing required field: {field}")

        elif config.provider_type == IdentityProvider.AZURE_AD:
            required_fields = ["tenant_id", "client_id", "client_secret"]
            for field in required_fields:
                if field not in config.config:
                    raise ValueError(f"Azure AD provider missing required field: {field}")

    def _serialize_session(self, session: UserSession) -> Dict[str, Any]:
        """Serialize session for API response."""
        return {
            "session_id": session.session_id,
            "user_id": session.user_id,
            "created_at": session.created_at.isoformat(),
            "last_activity": session.last_activity.isoformat(),
            "expires_at": session.expires_at.isoformat(),
            "status": session.status.value,
            "permissions": list(session.permissions)
        }

    def _serialize_user(self, user: EnterpriseUser) -> Dict[str, Any]:
        """Serialize user for API response."""
        return {
            "user_id": user.user_id,
            "username": user.username,
            "email": user.email,
            "display_name": user.display_name,
            "groups": user.groups,
            "roles": user.roles,
            "provider": user.provider.value,
            "is_active": user.is_active,
            "last_sync": user.last_sync.isoformat()
        }

    async def _get_user_ip_history(self, user_id: str) -> List[str]:
        """Get user's IP address history."""
        # This would typically query from audit logs
        return ["192.168.1.100", "10.0.0.50"]

    async def _get_user_agent_history(self, user_id: str) -> List[str]:
        """Get user's user agent history."""
        # This would typically query from audit logs
        return ["Mozilla/5.0 (Windows NT 10.0; Win64; x64)"]

    async def _calculate_average_session_duration(self) -> float:
        """Calculate average session duration in minutes."""
        active_sessions = [
            s for s in self.active_sessions.values()
            if s.status == SessionStatus.ACTIVE
        ]

        if not active_sessions:
            return 0.0

        total_duration = sum(
            (datetime.utcnow() - session.created_at).total_seconds() / 60
            for session in active_sessions
        )

        return total_duration / len(active_sessions)

    async def _calculate_mfa_adoption_rate(self) -> float:
        """Calculate MFA adoption rate."""
        # This would calculate based on user MFA setup
        return 0.85  # 85% placeholder

    async def _calculate_risk_score_distribution(self) -> Dict[str, int]:
        """Calculate risk score distribution."""
        # This would analyze actual risk scores
        return {
            "low": 70,
            "medium": 25,
            "high": 5
        }

    async def _session_cleanup_loop(self):
        """Background task for session cleanup."""
        while True:
            try:
                current_time = datetime.utcnow()
                expired_sessions = []

                for session_id, session in self.active_sessions.items():
                    if (session.status == SessionStatus.ACTIVE and
                        current_time > session.expires_at):
                        expired_sessions.append(session_id)

                # Clean up expired sessions
                for session_id in expired_sessions:
                    await self._revoke_session(session_id, "expired")

                if expired_sessions:
                    logging.info(f"Cleaned up {len(expired_sessions)} expired sessions")

                await asyncio.sleep(300)  # Check every 5 minutes

            except Exception as e:
                logging.error(f"Session cleanup error: {str(e)}")
                await asyncio.sleep(60)

    async def _user_sync_loop(self):
        """Background task for user synchronization."""
        while True:
            try:
                if self.user_provisioner:
                    await self.user_provisioner.sync_users()

                await asyncio.sleep(3600)  # Sync every hour

            except Exception as e:
                logging.error(f"User sync error: {str(e)}")
                await asyncio.sleep(600)

    async def _metrics_collection_loop(self):
        """Background task for metrics collection."""
        while True:
            try:
                # Update active sessions count
                self.auth_metrics["active_sessions"] = len([
                    s for s in self.active_sessions.values()
                    if s.status == SessionStatus.ACTIVE
                ])

                await asyncio.sleep(60)  # Update every minute

            except Exception as e:
                logging.error(f"Metrics collection error: {str(e)}")
                await asyncio.sleep(30)
```

2. **SAML 2.0 Authentication Handler** (`app/auth/saml_handler.py`):
```python
from typing import Dict, Any, Optional
import xml.etree.ElementTree as ET
from xml.dom import minidom
import base64
import zlib
import urllib.parse
from datetime import datetime, timedelta
import uuid
import hashlib
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.x509 import load_pem_x509_certificate
import logging

class SAML2Handler:
    """SAML 2.0 authentication handler."""

    def __init__(self):
        self.namespaces = {
            'saml': 'urn:oasis:names:tc:SAML:2.0:assertion',
            'samlp': 'urn:oasis:names:tc:SAML:2.0:protocol',
            'ds': 'http://www.w3.org/2000/09/xmldsig#'
        }

    async def authenticate(self, provider_config: IdentityProviderConfig,
                         authentication_data: Dict[str, Any],
                         context: Dict[str, Any]) -> Dict[str, Any]:
        """Handle SAML authentication."""
        try:
            if "saml_response" in authentication_data:
                # Process SAML response
                return await self._process_saml_response(
                    authentication_data["saml_response"],
                    provider_config
                )
            else:
                # Generate SAML request
                return await self._generate_saml_request(
                    provider_config, context
                )

        except Exception as e:
            logging.error(f"SAML authentication error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _generate_saml_request(self, provider_config: IdentityProviderConfig,
                                   context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SAML authentication request."""
        config = provider_config.config

        # Generate request ID and timestamp
        request_id = str(uuid.uuid4())
        timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ')

        # Build SAML request XML
        saml_request = f"""<?xml version="1.0" encoding="UTF-8"?>
<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                    xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
                    ID="{request_id}"
                    Version="2.0"
                    IssueInstant="{timestamp}"
                    Destination="{config['sso_url']}"
                    ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
                    AssertionConsumerServiceURL="{config.get('acs_url', 'https://mobius.example.com/saml/acs')}">
    <saml:Issuer>{config['entity_id']}</saml:Issuer>
    <samlp:NameIDPolicy Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
                        AllowCreate="true"/>
</samlp:AuthnRequest>"""

        # Sign request if required
        if config.get("sign_requests", False):
            saml_request = await self._sign_saml_request(saml_request, config)

        # Encode request
        encoded_request = base64.b64encode(
            zlib.compress(saml_request.encode('utf-8'))[2:-4]
        ).decode('utf-8')

        # Build redirect URL
        params = {
            'SAMLRequest': encoded_request,
            'RelayState': context.get('relay_state', '')
        }

        redirect_url = f"{config['sso_url']}?{urllib.parse.urlencode(params)}"

        return {
            "success": True,
            "redirect_url": redirect_url,
            "request_id": request_id
        }

    async def _process_saml_response(self, saml_response: str,
                                   provider_config: IdentityProviderConfig) -> Dict[str, Any]:
        """Process SAML authentication response."""
        try:
            # Decode SAML response
            decoded_response = base64.b64decode(saml_response)

            # Parse XML
            root = ET.fromstring(decoded_response)

            # Validate response
            validation_result = await self._validate_saml_response(root, provider_config)
            if not validation_result["valid"]:
                return {
                    "success": False,
                    "error": validation_result["error"]
                }

            # Extract user attributes
            user_info = await self._extract_user_attributes(root, provider_config)

            return {
                "success": True,
                "user_info": user_info
            }

        except Exception as e:
            logging.error(f"SAML response processing error: {str(e)}")
            return {
                "success": False,
                "error": f"Invalid SAML response: {str(e)}"
            }

    async def _validate_saml_response(self, root: ET.Element,
                                    provider_config: IdentityProviderConfig) -> Dict[str, Any]:
        """Validate SAML response."""
        config = provider_config.config

        try:
            # Check response status
            status_code = root.find('.//samlp:StatusCode', self.namespaces)
            if status_code is None or status_code.get('Value') != 'urn:oasis:names:tc:SAML:2.0:status:Success':
                return {
                    "valid": False,
                    "error": "SAML response indicates authentication failure"
                }

            # Check assertion presence
            assertion = root.find('.//saml:Assertion', self.namespaces)
            if assertion is None:
                return {
                    "valid": False,
                    "error": "No assertion found in SAML response"
                }

            # Validate signature if required
            if config.get("verify_signature", True):
                signature_valid = await self._verify_signature(root, config)
                if not signature_valid:
                    return {
                        "valid": False,
                        "error": "Invalid SAML response signature"
                    }

            # Validate conditions
            conditions_valid = await self._validate_conditions(assertion)
            if not conditions_valid:
                return {
                    "valid": False,
                    "error": "SAML assertion conditions not met"
                }

            return {"valid": True}

        except Exception as e:
            return {
                "valid": False,
                "error": f"SAML validation error: {str(e)}"
            }

    async def _extract_user_attributes(self, root: ET.Element,
                                     provider_config: IdentityProviderConfig) -> Dict[str, Any]:
        """Extract user attributes from SAML assertion."""
        user_info = {}
        attribute_mapping = provider_config.attribute_mapping

        # Extract NameID
        nameid = root.find('.//saml:NameID', self.namespaces)
        if nameid is not None:
            user_info['username'] = nameid.text
            user_info['email'] = nameid.text  # Assume NameID is email

        # Extract attributes
        attributes = root.findall('.//saml:Attribute', self.namespaces)
        for attr in attributes:
            attr_name = attr.get('Name')
            attr_values = [av.text for av in attr.findall('.//saml:AttributeValue', self.namespaces)]

            if attr_values:
                # Map attribute to internal field
                internal_field = None
                for internal, external in attribute_mapping.items():
                    if external == attr_name:
                        internal_field = internal
                        break

                if internal_field:
                    user_info[internal_field] = attr_values[0] if len(attr_values) == 1 else attr_values
                else:
                    user_info[attr_name] = attr_values[0] if len(attr_values) == 1 else attr_values

        # Ensure required fields
        if 'email' not in user_info and 'username' in user_info:
            user_info['email'] = user_info['username']
        if 'display_name' not in user_info:
            first_name = user_info.get('first_name', '')
            last_name = user_info.get('last_name', '')
            user_info['display_name'] = f"{first_name} {last_name}".strip() or user_info.get('email', 'Unknown')

        return user_info

    async def _sign_saml_request(self, saml_request: str,
                               config: Dict[str, Any]) -> str:
        """Sign SAML request."""
        # Implementation would add XML signature
        # For now, return unsigned request
        return saml_request

    async def _verify_signature(self, root: ET.Element,
                              config: Dict[str, Any]) -> bool:
        """Verify SAML response signature."""
        try:
            # Find signature element
            signature = root.find('.//ds:Signature', self.namespaces)
            if signature is None:
                return False

            # Load certificate
            cert_pem = config.get('certificate')
            if not cert_pem:
                return False

            certificate = load_pem_x509_certificate(cert_pem.encode())
            public_key = certificate.public_key()

            # Verify signature (simplified implementation)
            # In production, this would perform proper XML signature verification
            return True

        except Exception as e:
            logging.error(f"Signature verification error: {str(e)}")
            return False

    async def _validate_conditions(self, assertion: ET.Element) -> bool:
        """Validate SAML assertion conditions."""
        try:
            conditions = assertion.find('.//saml:Conditions', self.namespaces)
            if conditions is None:
                return True  # No conditions to validate

            # Check time bounds
            not_before = conditions.get('NotBefore')
            not_on_or_after = conditions.get('NotOnOrAfter')

            current_time = datetime.utcnow()

            if not_before:
                not_before_time = datetime.fromisoformat(not_before.replace('Z', '+00:00'))
                if current_time < not_before_time:
                    return False

            if not_on_or_after:
                not_on_or_after_time = datetime.fromisoformat(not_on_or_after.replace('Z', '+00:00'))
                if current_time >= not_on_or_after_time:
                    return False

            return True

        except Exception as e:
            logging.error(f"Conditions validation error: {str(e)}")
            return False
```

3. **Multi-Factor Authentication Manager** (`app/auth/mfa_manager.py`):
```python
import pyotp
import qrcode
import io
import base64
import secrets
import asyncio
import time
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import logging
import aioredis
import aiohttp
from twilio.rest import Client as TwilioClient
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart

@dataclass
class MFAMethod:
    method_type: AuthenticationMethod
    enabled: bool
    priority: int
    config: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MFAChallenge:
    challenge_id: str
    user_id: str
    method: AuthenticationMethod
    code: str
    created_at: datetime
    expires_at: datetime
    attempts: int = 0
    max_attempts: int = 3
    metadata: Dict[str, Any] = field(default_factory=dict)

class MFAManager:
    """Multi-Factor Authentication Manager."""

    def __init__(self, required: bool = True):
        self.required = required
        self.active_challenges: Dict[str, MFAChallenge] = {}
        self.user_mfa_methods: Dict[str, List[MFAMethod]] = {}
        self.backup_codes: Dict[str, List[str]] = {}

        # MFA configuration
        self.config = {
            "totp_window": 1,  # Allow 1 time step before/after
            "sms_timeout_minutes": 5,
            "email_timeout_minutes": 10,
            "max_attempts": 3,
            "rate_limit_window_minutes": 15,
            "backup_codes_count": 10
        }

        # External service clients
        self.twilio_client: Optional[TwilioClient] = None
        self.redis_client: Optional[aioredis.Redis] = None

        # Initialize services
        asyncio.create_task(self._initialize_mfa_services())

    async def _initialize_mfa_services(self):
        """Initialize MFA external services."""
        try:
            # Initialize Twilio for SMS
            # self.twilio_client = TwilioClient(account_sid, auth_token)

            # Initialize Redis for rate limiting
            # self.redis_client = aioredis.from_url("redis://localhost:6379")

            logging.info("MFA services initialized")

        except Exception as e:
            logging.warning(f"MFA services initialization failed: {str(e)}")

    async def setup_totp(self, user_id: str, user_email: str) -> Dict[str, Any]:
        """Set up TOTP for user."""
        try:
            # Generate secret key
            secret = pyotp.random_base32()

            # Create TOTP instance
            totp = pyotp.TOTP(secret)

            # Generate QR code URL
            provisioning_uri = totp.provisioning_uri(
                name=user_email,
                issuer_name="Mobius Context Engine"
            )

            # Generate QR code image
            qr = qrcode.QRCode(version=1, box_size=10, border=5)
            qr.add_data(provisioning_uri)
            qr.make(fit=True)

            img = qr.make_image(fill_color="black", back_color="white")

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            qr_code_data = base64.b64encode(buffer.getvalue()).decode()

            # Store TOTP method (temporarily until verification)
            if user_id not in self.user_mfa_methods:
                self.user_mfa_methods[user_id] = []

            # Generate backup codes
            backup_codes = await self._generate_backup_codes(user_id)

            return {
                "success": True,
                "secret": secret,
                "qr_code": f"data:image/png;base64,{qr_code_data}",
                "backup_codes": backup_codes,
                "manual_entry_key": secret
            }

        except Exception as e:
            logging.error(f"TOTP setup error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def verify_totp_setup(self, user_id: str, secret: str, code: str) -> Dict[str, Any]:
        """Verify TOTP setup with user-provided code."""
        try:
            totp = pyotp.TOTP(secret)

            if totp.verify(code, valid_window=self.config["totp_window"]):
                # Add TOTP method to user
                totp_method = MFAMethod(
                    method_type=AuthenticationMethod.TOTP,
                    enabled=True,
                    priority=1,
                    config={"secret": secret}
                )

                if user_id not in self.user_mfa_methods:
                    self.user_mfa_methods[user_id] = []

                self.user_mfa_methods[user_id].append(totp_method)

                return {
                    "success": True,
                    "message": "TOTP setup completed successfully"
                }
            else:
                return {
                    "success": False,
                    "error": "Invalid TOTP code"
                }

        except Exception as e:
            logging.error(f"TOTP verification error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def initiate_challenge(self, user_id: str,
                               auth_context: AuthenticationContext) -> Dict[str, Any]:
        """Initiate MFA challenge for user."""
        try:
            # Get user's MFA methods
            user_methods = self.user_mfa_methods.get(user_id, [])
            enabled_methods = [m for m in user_methods if m.enabled]

            if not enabled_methods:
                # Set up default SMS method if no MFA configured
                phone_number = await self._get_user_phone(user_id)
                if phone_number:
                    return await self._initiate_sms_challenge(
                        user_id, phone_number, auth_context.session_id
                    )
                else:
                    return {
                        "success": False,
                        "error": "No MFA methods configured"
                    }

            # Select highest priority method
            primary_method = max(enabled_methods, key=lambda m: m.priority)

            # Initiate challenge based on method type
            if primary_method.method_type == AuthenticationMethod.TOTP:
                return await self._initiate_totp_challenge(
                    user_id, auth_context.session_id
                )
            elif primary_method.method_type == AuthenticationMethod.SMS:
                phone_number = primary_method.config.get("phone_number")
                return await self._initiate_sms_challenge(
                    user_id, phone_number, auth_context.session_id
                )
            elif primary_method.method_type == AuthenticationMethod.EMAIL:
                email = primary_method.config.get("email")
                return await self._initiate_email_challenge(
                    user_id, email, auth_context.session_id
                )
            else:
                return {
                    "success": False,
                    "error": f"Unsupported MFA method: {primary_method.method_type.value}"
                }

        except Exception as e:
            logging.error(f"MFA challenge initiation error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def verify_code(self, session_id: str, code: str,
                         method: AuthenticationMethod) -> Dict[str, Any]:
        """Verify MFA code."""
        try:
            # Find active challenge for session
            challenge = None
            for c in self.active_challenges.values():
                if c.user_id == session_id and c.method == method:  # Using session_id as user identifier
                    challenge = c
                    break

            if not challenge:
                return {
                    "success": False,
                    "error": "No active MFA challenge found"
                }

            # Check if challenge expired
            if datetime.utcnow() > challenge.expires_at:
                del self.active_challenges[challenge.challenge_id]
                return {
                    "success": False,
                    "error": "MFA challenge expired"
                }

            # Check attempt limit
            if challenge.attempts >= challenge.max_attempts:
                del self.active_challenges[challenge.challenge_id]
                return {
                    "success": False,
                    "error": "Too many failed attempts"
                }

            challenge.attempts += 1

            # Verify code based on method
            verification_success = False

            if method == AuthenticationMethod.TOTP:
                verification_success = await self._verify_totp_code(
                    challenge.user_id, code
                )
            elif method in [AuthenticationMethod.SMS, AuthenticationMethod.EMAIL]:
                verification_success = (code == challenge.code)
            else:
                return {
                    "success": False,
                    "error": f"Unsupported verification method: {method.value}"
                }

            if verification_success:
                # Clean up challenge
                user_id = challenge.user_id
                del self.active_challenges[challenge.challenge_id]

                return {
                    "success": True,
                    "user_id": user_id,
                    "method": method.value
                }
            else:
                return {
                    "success": False,
                    "error": "Invalid MFA code",
                    "attempts_remaining": challenge.max_attempts - challenge.attempts
                }

        except Exception as e:
            logging.error(f"MFA verification error: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _initiate_totp_challenge(self, user_id: str, session_id: str) -> Dict[str, Any]:
        """Initiate TOTP challenge."""
        challenge_id = secrets.token_urlsafe(32)

        challenge = MFAChallenge(
            challenge_id=challenge_id,
            user_id=user_id,
            method=AuthenticationMethod.TOTP,
            code="",  # TOTP doesn't need stored code
            created_at=datetime.utcnow(),
            expires_at=datetime.utcnow() + timedelta(minutes=5)
        )

        self.active_challenges[challenge_id] = challenge

        return {
            "success": True,
            "challenge_id": challenge_id,
            "method": "totp",
            "message": "Please enter your TOTP code from your authenticator app"
        }

    async def _initiate_sms_challenge(self, user_id: str, phone_number: str,
                                    session_id: str) -> Dict[str, Any]:
        """Initiate SMS challenge."""
        # Check rate limiting
        if await self._is_rate_limited(user_id, "sms"):
            return {
                "success": False,
                "error": "SMS rate limit exceeded"
            }

        # Generate verification code
        code = f"{secrets.randbelow(900000) + 100000:06d}"
        challenge_id = secrets.token_urlsafe(32)

        challenge = MFAChallenge(
            challenge_id=challenge_id,
            user_id=user_id,
            method=AuthenticationMethod.SMS,
            code=code,
            created_at=datetime.utcnow(),
            expires_at=datetime.utcnow() + timedelta(minutes=self.config["sms_timeout_minutes"]),
            metadata={"phone_number": phone_number}
        )

        # Send SMS
        sms_sent = await self._send_sms(phone_number, code)

        if sms_sent:
            self.active_challenges[challenge_id] = challenge
            await self._record_rate_limit(user_id, "sms")

            return {
                "success": True,
                "challenge_id": challenge_id,
                "method": "sms",
                "message": f"SMS code sent to {self._mask_phone_number(phone_number)}"
            }
        else:
            return {
                "success": False,
                "error": "Failed to send SMS"
            }

    async def _initiate_email_challenge(self, user_id: str, email: str,
                                      session_id: str) -> Dict[str, Any]:
        """Initiate email challenge."""
        # Check rate limiting
        if await self._is_rate_limited(user_id, "email"):
            return {
                "success": False,
                "error": "Email rate limit exceeded"
            }

        # Generate verification code
        code = f"{secrets.randbelow(900000) + 100000:06d}"
        challenge_id = secrets.token_urlsafe(32)

        challenge = MFAChallenge(
            challenge_id=challenge_id,
            user_id=user_id,
            method=AuthenticationMethod.EMAIL,
            code=code,
            created_at=datetime.utcnow(),
            expires_at=datetime.utcnow() + timedelta(minutes=self.config["email_timeout_minutes"]),
            metadata={"email": email}
        )

        # Send email
        email_sent = await self._send_email(email, code)

        if email_sent:
            self.active_challenges[challenge_id] = challenge
            await self._record_rate_limit(user_id, "email")

            return {
                "success": True,
                "challenge_id": challenge_id,
                "method": "email",
                "message": f"Verification code sent to {self._mask_email(email)}"
            }
        else:
            return {
                "success": False,
                "error": "Failed to send email"
            }

    async def _verify_totp_code(self, user_id: str, code: str) -> bool:
        """Verify TOTP code for user."""
        try:
            user_methods = self.user_mfa_methods.get(user_id, [])
            totp_methods = [m for m in user_methods
                          if m.method_type == AuthenticationMethod.TOTP and m.enabled]

            for method in totp_methods:
                secret = method.config.get("secret")
                if secret:
                    totp = pyotp.TOTP(secret)
                    if totp.verify(code, valid_window=self.config["totp_window"]):
                        return True

            return False

        except Exception as e:
            logging.error(f"TOTP verification error: {str(e)}")
            return False

    async def _send_sms(self, phone_number: str, code: str) -> bool:
        """Send SMS verification code."""
        try:
            if not self.twilio_client:
                logging.warning("Twilio client not configured")
                return False

            message = f"Your Mobius verification code is: {code}. This code expires in {self.config['sms_timeout_minutes']} minutes."

            # Send SMS using Twilio
            # message = self.twilio_client.messages.create(
            #     body=message,
            #     from_='+1234567890',  # Your Twilio number
            #     to=phone_number
            # )

            # For now, just log the code
            logging.info(f"SMS code for {self._mask_phone_number(phone_number)}: {code}")

            return True

        except Exception as e:
            logging.error(f"SMS sending error: {str(e)}")
            return False

    async def _send_email(self, email: str, code: str) -> bool:
        """Send email verification code."""
        try:
            subject = "Mobius Verification Code"
            message = f"""
            Your Mobius verification code is: {code}

            This code expires in {self.config['email_timeout_minutes']} minutes.

            If you didn't request this code, please ignore this email.
            """

            # For now, just log the code
            logging.info(f"Email code for {self._mask_email(email)}: {code}")

            return True

        except Exception as e:
            logging.error(f"Email sending error: {str(e)}")
            return False

    async def _generate_backup_codes(self, user_id: str) -> List[str]:
        """Generate backup codes for user."""
        backup_codes = []
        for _ in range(self.config["backup_codes_count"]):
            code = f"{secrets.randbelow(90000000) + 10000000:08d}"
            backup_codes.append(code)

        # Store backup codes (hashed)
        hashed_codes = [hashlib.sha256(code.encode()).hexdigest() for code in backup_codes]
        self.backup_codes[user_id] = hashed_codes

        return backup_codes

    async def _is_rate_limited(self, user_id: str, method: str) -> bool:
        """Check if user is rate limited for MFA method."""
        # This would typically use Redis for distributed rate limiting
        # For now, implement simple in-memory rate limiting
        return False

    async def _record_rate_limit(self, user_id: str, method: str):
        """Record rate limit event."""
        # This would typically record in Redis
        pass

    async def _get_user_phone(self, user_id: str) -> Optional[str]:
        """Get user's phone number."""
        # This would typically query from user database
        return "+1234567890"  # Placeholder

    def _mask_phone_number(self, phone_number: str) -> str:
        """Mask phone number for display."""
        if len(phone_number) > 4:
            return f"***-***-{phone_number[-4:]}"
        return "***-***-****"

    def _mask_email(self, email: str) -> str:
        """Mask email for display."""
        if '@' in email:
            local, domain = email.split('@', 1)
            if len(local) > 2:
                masked_local = f"{local[0]}***{local[-1]}"
            else:
                masked_local = "***"
            return f"{masked_local}@{domain}"
        return "***@***.***"
```

## Dependencies
- Task 040: Advanced Security Framework
- Task 008: Async Database Operations
- Task 025: Redis Integration
- Task 043: Real-time Performance Monitoring System
- SAML/OIDC libraries (python-saml, authlib)
- MFA libraries (pyotp, qrcode)
- External service integrations (Twilio, SendGrid)
- Enterprise directory integration libraries (ldap3, azure-identity)
- Cryptography libraries for encryption and signing

## Estimated Time
40-50 hours

## Required Skills
- Enterprise authentication protocols (SAML, OIDC, OAuth 2.0)
- Multi-factor authentication implementation
- Cryptographic operations and certificate management
- Enterprise directory integration (LDAP, Active Directory)
- Session management and security
- Compliance and security standards (SOC 2, GDPR)
- Identity provider integration experience
- Enterprise security architecture design
