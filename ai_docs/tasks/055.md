# Task 055: Model Context Protocol (MCP) Integration System

## Overview
Implement a comprehensive Model Context Protocol (MCP) integration system that enables seamless integration with external AI applications, tools, and data sources. This system will provide standardized interfaces for context sharing, tool discovery, resource management, and cross-platform interoperability while maintaining security and performance standards.

## Success Criteria
- [ ] MCP server supports all core protocol features (prompts, resources, tools, completions)
- [ ] Integration with 5+ external MCP-compatible tools and services
- [ ] Protocol compliance achieves 100% compatibility with MCP specification
- [ ] Context sharing latency remains <100ms for standard operations
- [ ] Security model prevents unauthorized access to sensitive resources
- [ ] Plugin marketplace supports 20+ community-developed MCP extensions

## Test First Approach

### Tests to Write BEFORE Implementation:

1. **MCP Protocol Compliance Tests** (`tests/backend/unit/test_mcp_protocol.py`):
```python
def test_mcp_server_initialization():
    """Test MCP server initialization and capability negotiation."""
    # Test server startup and capability declaration
    # Test client connection and handshake
    # Test protocol version negotiation
    # Test server metadata exchange
    # Test initialization options validation

def test_mcp_message_handling():
    """Test MCP message protocol compliance."""
    # Test JSON-RPC 2.0 message format compliance
    # Test request/response message handling
    # Test notification message handling
    # Test error response formatting
    # Test message validation and schema compliance

def test_mcp_transport_layers():
    """Test MCP transport layer implementations."""
    # Test stdio transport for local connections
    # Test SSE (Server-Sent Events) transport for HTTP
    # Test WebSocket transport for real-time connections
    # Test transport fallback and negotiation
    # Test connection recovery and reconnection
```

2. **MCP Resource Management Tests** (`tests/backend/unit/test_mcp_resources.py`):
```python
def test_resource_discovery():
    """Test MCP resource discovery and listing."""
    # Test resource listing with pagination
    # Test resource template patterns
    # Test resource URI resolution
    # Test resource metadata retrieval
    # Test dynamic resource discovery

def test_resource_access_control():
    """Test resource access control and security."""
    # Test resource permission validation
    # Test user-based resource filtering
    # Test organization-based access control
    # Test resource subscription management
    # Test audit logging for resource access

def test_resource_content_delivery():
    """Test resource content retrieval and caching."""
    # Test resource content streaming
    # Test large file handling and chunking
    # Test content type negotiation
    # Test caching strategies for resources
    # Test resource update notifications
```

3. **MCP Tool Integration Tests** (`tests/backend/unit/test_mcp_tools.py`):
```python
def test_tool_discovery():
    """Test MCP tool discovery and registration."""
    # Test tool listing and metadata
    # Test tool schema validation
    # Test tool capability advertisement
    # Test dynamic tool registration
    # Test tool versioning and updates

def test_tool_execution():
    """Test MCP tool execution and results."""
    # Test synchronous tool execution
    # Test asynchronous tool execution
    # Test tool parameter validation
    # Test tool result formatting
    # Test error handling and reporting

def test_tool_security():
    """Test tool execution security and sandboxing."""
    # Test tool permission validation
    # Test input sanitization and validation
    # Test execution timeout and limits
    # Test resource access restrictions
    # Test audit trail for tool executions
```

## Implementation Details

### 1. MCP Server Core Implementation (`app/mcp_integration/server.py`):
```python
import asyncio
import json
import logging
from typing import Dict, List, Any, Optional, Callable, Union
from dataclasses import dataclass, asdict
from datetime import datetime
import uuid

from mcp.server.fastmcp import FastMCP, Context
from mcp.server.models import InitializationOptions
from mcp.server.lowlevel import NotificationOptions, Server
from mcp import types
import aioredis
import asyncpg
from fastapi import HTTPException

@dataclass
class MCPResource:
    """MCP resource definition."""
    uri: str
    name: str
    description: Optional[str]
    mime_type: Optional[str]
    content_provider: Callable[[], str]
    access_level: str = "public"
    organization_id: Optional[str] = None
    user_id: Optional[str] = None

@dataclass
class MCPTool:
    """MCP tool definition."""
    name: str
    description: str
    input_schema: Dict[str, Any]
    output_schema: Optional[Dict[str, Any]]
    handler: Callable
    access_level: str = "public"
    organization_id: Optional[str] = None
    timeout_seconds: int = 30

class MobiusMCPServer:
    """Advanced MCP server for Mobius Context Engineering Platform."""

    def __init__(self, postgres_url: str, redis_url: str):
        self.postgres_url = postgres_url
        self.redis_url = redis_url
        self.postgres_pool = None
        self.redis_pool = None

        # Initialize FastMCP server
        self.mcp = FastMCP(
            name="Mobius Context Engine",
            dependencies=["asyncpg", "aioredis", "httpx", "pandas"]
        )

        # Resource and tool registries
        self.resources: Dict[str, MCPResource] = {}
        self.tools: Dict[str, MCPTool] = {}
        self.active_sessions: Dict[str, Dict[str, Any]] = {}

        # Setup core handlers
        self._setup_core_handlers()

    async def initialize(self):
        """Initialize MCP server with database connections."""
        try:
            # Initialize database connections
            self.postgres_pool = await asyncpg.create_pool(
                self.postgres_url,
                min_size=3,
                max_size=10
            )

            self.redis_pool = aioredis.ConnectionPool.from_url(
                self.redis_url, max_connections=10
            )

            # Register default resources and tools
            await self._register_default_resources()
            await self._register_default_tools()

            logging.info("Mobius MCP Server initialized successfully")

        except Exception as e:
            logging.error(f"Failed to initialize MCP server: {e}")
            raise

    def _setup_core_handlers(self):
        """Setup core MCP protocol handlers."""

        # Resource handlers
        @self.mcp.resource("context://projects/{project_id}/files/{file_path}")
        async def get_project_file(project_id: str, file_path: str) -> str:
            """Get project file content."""
            return await self._get_project_file_content(project_id, file_path)

        @self.mcp.resource("context://projects/{project_id}/summary")
        async def get_project_summary(project_id: str) -> str:
            """Get project context summary."""
            return await self._get_project_summary(project_id)

        @self.mcp.resource("context://search/{query}")
        async def search_context(query: str) -> str:
            """Search context database."""
            return await self._search_context_database(query)

        # Tool handlers
        @self.mcp.tool()
        async def analyze_code_context(
            file_path: str,
            analysis_type: str = "full",
            ctx: Context = None
        ) -> Dict[str, Any]:
            """Analyze code context and dependencies."""
            return await self._analyze_code_context(file_path, analysis_type, ctx)

        @self.mcp.tool()
        async def generate_context_summary(
            project_id: str,
            scope: str = "full",
            ctx: Context = None
        ) -> Dict[str, Any]:
            """Generate comprehensive context summary."""
            return await self._generate_context_summary(project_id, scope, ctx)

        @self.mcp.tool()
        async def search_similar_code(
            code_snippet: str,
            similarity_threshold: float = 0.8,
            ctx: Context = None
        ) -> List[Dict[str, Any]]:
            """Search for similar code patterns."""
            return await self._search_similar_code(code_snippet, similarity_threshold, ctx)

        # Prompt handlers
        @self.mcp.prompt()
        async def code_review_prompt(
            file_path: str,
            focus_areas: str = "general"
        ) -> str:
            """Generate code review prompt with context."""
            context = await self._get_file_context(file_path)
            return f"""Please review this code with focus on {focus_areas}:

Context: {context}

Consider:
1. Code quality and best practices
2. Security implications
3. Performance considerations
4. Maintainability factors
5. Integration patterns

Provide specific, actionable feedback."""

        @self.mcp.prompt()
        async def debugging_prompt(
            error_message: str,
            file_path: str = "",
            context_lines: int = 10
        ) -> str:
            """Generate debugging prompt with relevant context."""
            file_context = ""
            if file_path:
                file_context = await self._get_file_context_with_lines(
                    file_path, context_lines
                )

            return f"""Help debug this error:

Error: {error_message}

Context:
{file_context}

Please:
1. Analyze the error and its likely causes
2. Suggest specific solutions
3. Recommend debugging steps
4. Identify related code patterns that might be affected"""

    async def _register_default_resources(self):
        """Register default MCP resources."""
        try:
            # Project listing resource
            self.resources["projects"] = MCPResource(
                uri="context://projects",
                name="Project List",
                description="List of available projects",
                mime_type="application/json",
                content_provider=self._get_projects_list
            )

            # Context statistics resource
            self.resources["stats"] = MCPResource(
                uri="context://stats",
                name="Context Statistics",
                description="Platform usage and context statistics",
                mime_type="application/json",
                content_provider=self._get_context_statistics
            )

            # Recent activity resource
            self.resources["activity"] = MCPResource(
                uri="context://activity",
                name="Recent Activity",
                description="Recent context operations and updates",
                mime_type="application/json",
                content_provider=self._get_recent_activity
            )

        except Exception as e:
            logging.error(f"Error registering default resources: {e}")

    async def _register_default_tools(self):
        """Register default MCP tools."""
        try:
            # Vector search tool
            self.tools["vector_search"] = MCPTool(
                name="vector_search",
                description="Perform semantic vector search across codebase",
                input_schema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Search query"},
                        "limit": {"type": "integer", "default": 10},
                        "similarity_threshold": {"type": "number", "default": 0.7}
                    },
                    "required": ["query"]
                },
                output_schema={
                    "type": "object",
                    "properties": {
                        "results": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "file_path": {"type": "string"},
                                    "similarity_score": {"type": "number"},
                                    "snippet": {"type": "string"},
                                    "context": {"type": "string"}
                                }
                            }
                        },
                        "total_count": {"type": "integer"}
                    }
                },
                handler=self._handle_vector_search
            )

            # Code analysis tool
            self.tools["code_analysis"] = MCPTool(
                name="code_analysis",
                description="Perform comprehensive code analysis",
                input_schema={
                    "type": "object",
                    "properties": {
                        "file_path": {"type": "string", "description": "Path to analyze"},
                        "analysis_depth": {
                            "type": "string",
                            "enum": ["surface", "medium", "deep"],
                            "default": "medium"
                        }
                    },
                    "required": ["file_path"]
                },
                handler=self._handle_code_analysis
            )

        except Exception as e:
            logging.error(f"Error registering default tools: {e}")

    async def _get_project_file_content(self, project_id: str, file_path: str) -> str:
        """Get content of a project file."""
        try:
            async with self.postgres_pool.acquire() as conn:
                result = await conn.fetchrow(
                    """
                    SELECT content, file_type, last_modified
                    FROM project_files
                    WHERE project_id = $1 AND file_path = $2
                    """,
                    project_id, file_path
                )

                if not result:
                    raise HTTPException(status_code=404, detail="File not found")

                return json.dumps({
                    "content": result["content"],
                    "file_type": result["file_type"],
                    "last_modified": result["last_modified"].isoformat(),
                    "file_path": file_path
                })

        except Exception as e:
            logging.error(f"Error getting project file content: {e}")
            raise

    async def _get_project_summary(self, project_id: str) -> str:
        """Get project context summary."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Get project metadata
                project = await conn.fetchrow(
                    "SELECT * FROM projects WHERE id = $1", project_id
                )

                if not project:
                    raise HTTPException(status_code=404, detail="Project not found")

                # Get file statistics
                file_stats = await conn.fetch(
                    """
                    SELECT
                        file_type,
                        COUNT(*) as file_count,
                        SUM(LENGTH(content)) as total_size
                    FROM project_files
                    WHERE project_id = $1
                    GROUP BY file_type
                    """,
                    project_id
                )

                # Get recent context operations
                recent_operations = await conn.fetch(
                    """
                    SELECT operation_type, COUNT(*) as count
                    FROM context_operations
                    WHERE project_id = $1
                    AND created_at > NOW() - INTERVAL '7 days'
                    GROUP BY operation_type
                    """,
                    project_id
                )

                summary = {
                    "project": dict(project),
                    "file_statistics": [dict(stat) for stat in file_stats],
                    "recent_operations": [dict(op) for op in recent_operations],
                    "summary_generated_at": datetime.utcnow().isoformat()
                }

                return json.dumps(summary, indent=2)

        except Exception as e:
            logging.error(f"Error getting project summary: {e}")
            raise

    async def _search_context_database(self, query: str) -> str:
        """Search context database using vector similarity."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Use vector similarity search
                results = await conn.fetch(
                    """
                    SELECT
                        file_path,
                        content_snippet,
                        embedding <-> $1::vector as distance,
                        metadata
                    FROM context_embeddings
                    WHERE embedding <-> $1::vector < 0.3
                    ORDER BY distance
                    LIMIT 20
                    """,
                    query  # This would be converted to vector embedding
                )

                search_results = {
                    "query": query,
                    "results": [
                        {
                            "file_path": result["file_path"],
                            "snippet": result["content_snippet"],
                            "similarity_score": 1 - result["distance"],
                            "metadata": result["metadata"]
                        }
                        for result in results
                    ],
                    "total_results": len(results)
                }

                return json.dumps(search_results, indent=2)

        except Exception as e:
            logging.error(f"Error searching context database: {e}")
            raise

    async def _analyze_code_context(
        self,
        file_path: str,
        analysis_type: str,
        ctx: Context
    ) -> Dict[str, Any]:
        """Analyze code context and dependencies."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Get file content and metadata
                file_data = await conn.fetchrow(
                    """
                    SELECT content, file_type, project_id
                    FROM project_files
                    WHERE file_path = $1
                    """,
                    file_path
                )

                if not file_data:
                    raise ValueError(f"File not found: {file_path}")

                # Perform analysis based on type
                analysis_result = {
                    "file_path": file_path,
                    "file_type": file_data["file_type"],
                    "analysis_type": analysis_type,
                    "timestamp": datetime.utcnow().isoformat()
                }

                if analysis_type == "full":
                    # Get dependencies
                    dependencies = await conn.fetch(
                        """
                        SELECT dependency_path, dependency_type
                        FROM file_dependencies
                        WHERE file_path = $1
                        """,
                        file_path
                    )

                    # Get similar files
                    similar_files = await conn.fetch(
                        """
                        SELECT similar_file_path, similarity_score
                        FROM file_similarities
                        WHERE file_path = $1
                        ORDER BY similarity_score DESC
                        LIMIT 10
                        """,
                        file_path
                    )

                    analysis_result.update({
                        "dependencies": [dict(dep) for dep in dependencies],
                        "similar_files": [dict(sim) for sim in similar_files],
                        "complexity_metrics": await self._calculate_complexity_metrics(file_data["content"])
                    })

                return analysis_result

        except Exception as e:
            logging.error(f"Error analyzing code context: {e}")
            raise

    async def _calculate_complexity_metrics(self, content: str) -> Dict[str, Any]:
        """Calculate code complexity metrics."""
        # This is a simplified implementation
        # In production, you'd use proper code analysis tools
        lines = content.split('\n')

        return {
            "total_lines": len(lines),
            "non_empty_lines": len([line for line in lines if line.strip()]),
            "comment_lines": len([line for line in lines if line.strip().startswith('#')]),
            "function_count": content.count('def '),
            "class_count": content.count('class '),
            "complexity_score": min(100, len(lines) // 10)  # Simplified score
        }

    async def register_external_tool(
        self,
        tool_definition: MCPTool,
        organization_id: Optional[str] = None
    ):
        """Register an external MCP tool."""
        try:
            # Validate tool definition
            if not tool_definition.name or not tool_definition.handler:
                raise ValueError("Tool must have name and handler")

            # Add organization context
            tool_definition.organization_id = organization_id

            # Store in registry
            self.tools[tool_definition.name] = tool_definition

            # Register with FastMCP
            @self.mcp.tool(
                name=tool_definition.name,
                description=tool_definition.description
            )
            async def external_tool_wrapper(*args, **kwargs):
                return await tool_definition.handler(*args, **kwargs)

            logging.info(f"Registered external tool: {tool_definition.name}")

        except Exception as e:
            logging.error(f"Error registering external tool: {e}")
            raise

    async def register_external_resource(
        self,
        resource_definition: MCPResource,
        organization_id: Optional[str] = None
    ):
        """Register an external MCP resource."""
        try:
            # Validate resource definition
            if not resource_definition.uri or not resource_definition.content_provider:
                raise ValueError("Resource must have URI and content provider")

            # Add organization context
            resource_definition.organization_id = organization_id

            # Store in registry
            self.resources[resource_definition.uri] = resource_definition

            # Register with FastMCP
            @self.mcp.resource(resource_definition.uri)
            async def external_resource_wrapper():
                return await resource_definition.content_provider()

            logging.info(f"Registered external resource: {resource_definition.uri}")

        except Exception as e:
            logging.error(f"Error registering external resource: {e}")
            raise

    async def get_server_capabilities(self) -> Dict[str, Any]:
        """Get MCP server capabilities."""
        return {
            "prompts": {
                "listChanged": True
            },
            "resources": {
                "subscribe": True,
                "listChanged": True
            },
            "tools": {
                "listChanged": True
            },
            "logging": {},
            "completion": {}
        }

    async def start_server(self, transport: str = "stdio", port: int = 3000):
        """Start the MCP server."""
        try:
            await self.initialize()

            if transport == "stdio":
                await self.mcp.run()
            elif transport == "sse":
                await self.mcp.run(transport="sse", port=port)
            elif transport == "streamable-http":
                await self.mcp.run(transport="streamable-http", port=port)
            else:
                raise ValueError(f"Unsupported transport: {transport}")

        except Exception as e:
            logging.error(f"Error starting MCP server: {e}")
            raise
```

### 2. MCP Plugin Marketplace (`app/mcp_integration/marketplace.py`):
```python
import asyncio
import json
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime
import uuid
import httpx
import asyncpg
from fastapi import HTTPException

@dataclass
class MCPPlugin:
    """MCP plugin definition."""
    id: str
    name: str
    description: str
    version: str
    author: str
    category: str
    plugin_url: str
    manifest_url: str
    install_count: int = 0
    rating: float = 0.0
    review_count: int = 0
    last_updated: Optional[datetime] = None
    is_verified: bool = False
    is_active: bool = True

@dataclass
class PluginInstallation:
    """Plugin installation record."""
    id: str
    plugin_id: str
    organization_id: str
    user_id: str
    installed_at: datetime
    configuration: Dict[str, Any]
    is_enabled: bool = True

class MCPPluginMarketplace:
    """MCP plugin marketplace for discovering and managing extensions."""

    def __init__(self, postgres_url: str, redis_url: str):
        self.postgres_url = postgres_url
        self.redis_url = redis_url
        self.postgres_pool = None
        self.redis_pool = None
        self.installed_plugins: Dict[str, PluginInstallation] = {}

    async def initialize(self):
        """Initialize plugin marketplace."""
        try:
            # Initialize database connections
            self.postgres_pool = await asyncpg.create_pool(
                self.postgres_url,
                min_size=2,
                max_size=5
            )

            # Create plugin tables if they don't exist
            await self._create_plugin_tables()

            # Load installed plugins
            await self._load_installed_plugins()

            logging.info("MCP Plugin Marketplace initialized successfully")

        except Exception as e:
            logging.error(f"Failed to initialize plugin marketplace: {e}")
            raise

    async def _create_plugin_tables(self):
        """Create plugin-related database tables."""
        try:
            async with self.postgres_pool.acquire() as conn:
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS mcp_plugins (
                        id VARCHAR PRIMARY KEY,
                        name VARCHAR NOT NULL,
                        description TEXT,
                        version VARCHAR NOT NULL,
                        author VARCHAR NOT NULL,
                        category VARCHAR NOT NULL,
                        plugin_url VARCHAR NOT NULL,
                        manifest_url VARCHAR NOT NULL,
                        install_count INTEGER DEFAULT 0,
                        rating DECIMAL(3,2) DEFAULT 0.0,
                        review_count INTEGER DEFAULT 0,
                        last_updated TIMESTAMP,
                        is_verified BOOLEAN DEFAULT FALSE,
                        is_active BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMP DEFAULT NOW(),
                        updated_at TIMESTAMP DEFAULT NOW()
                    )
                """)

                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS mcp_plugin_installations (
                        id VARCHAR PRIMARY KEY,
                        plugin_id VARCHAR REFERENCES mcp_plugins(id),
                        organization_id VARCHAR NOT NULL,
                        user_id VARCHAR NOT NULL,
                        installed_at TIMESTAMP DEFAULT NOW(),
                        configuration JSONB DEFAULT '{}',
                        is_enabled BOOLEAN DEFAULT TRUE
                    )
                """)

                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS mcp_plugin_reviews (
                        id VARCHAR PRIMARY KEY,
                        plugin_id VARCHAR REFERENCES mcp_plugins(id),
                        user_id VARCHAR NOT NULL,
                        organization_id VARCHAR NOT NULL,
                        rating INTEGER CHECK (rating >= 1 AND rating <= 5),
                        review_text TEXT,
                        created_at TIMESTAMP DEFAULT NOW()
                    )
                """)

                # Create indexes
                await conn.execute("""
                    CREATE INDEX IF NOT EXISTS idx_plugin_category
                    ON mcp_plugins(category)
                """)

                await conn.execute("""
                    CREATE INDEX IF NOT EXISTS idx_plugin_installations_org
                    ON mcp_plugin_installations(organization_id)
                """)

        except Exception as e:
            logging.error(f"Error creating plugin tables: {e}")
            raise

    async def discover_plugins(
        self,
        category: Optional[str] = None,
        search_query: Optional[str] = None,
        limit: int = 20,
        offset: int = 0
    ) -> Dict[str, Any]:
        """Discover available MCP plugins."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Build query based on filters
                where_conditions = ["is_active = TRUE"]
                params = []
                param_count = 0

                if category:
                    param_count += 1
                    where_conditions.append(f"category = ${param_count}")
                    params.append(category)

                if search_query:
                    param_count += 1
                    where_conditions.append(f"""
                        (name ILIKE ${param_count} OR description ILIKE ${param_count})
                    """)
                    params.append(f"%{search_query}%")

                where_clause = " AND ".join(where_conditions)

                # Get total count
                count_query = f"""
                    SELECT COUNT(*)
                    FROM mcp_plugins
                    WHERE {where_clause}
                """
                total_count = await conn.fetchval(count_query, *params)

                # Get plugins with pagination
                plugins_query = f"""
                    SELECT * FROM mcp_plugins
                    WHERE {where_clause}
                    ORDER BY install_count DESC, rating DESC
                    LIMIT ${param_count + 1} OFFSET ${param_count + 2}
                """
                params.extend([limit, offset])

                plugins_data = await conn.fetch(plugins_query, *params)

                plugins = [
                    MCPPlugin(
                        id=row["id"],
                        name=row["name"],
                        description=row["description"],
                        version=row["version"],
                        author=row["author"],
                        category=row["category"],
                        plugin_url=row["plugin_url"],
                        manifest_url=row["manifest_url"],
                        install_count=row["install_count"],
                        rating=float(row["rating"] or 0),
                        review_count=row["review_count"],
                        last_updated=row["last_updated"],
                        is_verified=row["is_verified"],
                        is_active=row["is_active"]
                    )
                    for row in plugins_data
                ]

                return {
                    "plugins": [asdict(plugin) for plugin in plugins],
                    "total_count": total_count,
                    "page_info": {
                        "limit": limit,
                        "offset": offset,
                        "has_next": offset + limit < total_count,
                        "has_previous": offset > 0
                    }
                }

        except Exception as e:
            logging.error(f"Error discovering plugins: {e}")
            raise

    async def install_plugin(
        self,
        plugin_id: str,
        organization_id: str,
        user_id: str,
        configuration: Optional[Dict[str, Any]] = None
    ) -> PluginInstallation:
        """Install an MCP plugin for an organization."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Check if plugin exists
                plugin_data = await conn.fetchrow(
                    "SELECT * FROM mcp_plugins WHERE id = $1 AND is_active = TRUE",
                    plugin_id
                )

                if not plugin_data:
                    raise HTTPException(status_code=404, detail="Plugin not found")

                # Check if already installed
                existing_installation = await conn.fetchrow(
                    """
                    SELECT id FROM mcp_plugin_installations
                    WHERE plugin_id = $1 AND organization_id = $2
                    """,
                    plugin_id, organization_id
                )

                if existing_installation:
                    raise HTTPException(
                        status_code=400,
                        detail="Plugin already installed"
                    )

                # Download and validate plugin manifest
                plugin_manifest = await self._validate_plugin_manifest(
                    plugin_data["manifest_url"]
                )

                # Create installation record
                installation_id = str(uuid.uuid4())
                await conn.execute(
                    """
                    INSERT INTO mcp_plugin_installations
                    (id, plugin_id, organization_id, user_id, configuration)
                    VALUES ($1, $2, $3, $4, $5)
                    """,
                    installation_id, plugin_id, organization_id, user_id,
                    json.dumps(configuration or {})
                )

                # Update install count
                await conn.execute(
                    """
                    UPDATE mcp_plugins
                    SET install_count = install_count + 1
                    WHERE id = $1
                    """,
                    plugin_id
                )

                # Create installation object
                installation = PluginInstallation(
                    id=installation_id,
                    plugin_id=plugin_id,
                    organization_id=organization_id,
                    user_id=user_id,
                    installed_at=datetime.utcnow(),
                    configuration=configuration or {},
                    is_enabled=True
                )

                # Store in memory
                self.installed_plugins[installation_id] = installation

                # Install plugin components
                await self._install_plugin_components(plugin_manifest, installation)

                logging.info(f"Plugin {plugin_id} installed for org {organization_id}")
                return installation

        except Exception as e:
            logging.error(f"Error installing plugin: {e}")
            raise

    async def _validate_plugin_manifest(self, manifest_url: str) -> Dict[str, Any]:
        """Download and validate plugin manifest."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(manifest_url)
                response.raise_for_status()

                manifest = response.json()

                # Validate required fields
                required_fields = ["name", "version", "mcp_version", "components"]
                for field in required_fields:
                    if field not in manifest:
                        raise ValueError(f"Missing required field: {field}")

                # Validate MCP version compatibility
                if not self._is_compatible_mcp_version(manifest["mcp_version"]):
                    raise ValueError(f"Incompatible MCP version: {manifest['mcp_version']}")

                return manifest

        except Exception as e:
            logging.error(f"Error validating plugin manifest: {e}")
            raise

    def _is_compatible_mcp_version(self, plugin_mcp_version: str) -> bool:
        """Check if plugin MCP version is compatible."""
        # Simplified version check - in production, use proper semver
        supported_versions = ["1.0", "1.1", "1.2"]
        return plugin_mcp_version in supported_versions

    async def _install_plugin_components(
        self,
        manifest: Dict[str, Any],
        installation: PluginInstallation
    ):
        """Install plugin components (tools, resources, prompts)."""
        try:
            components = manifest.get("components", {})

            # Install tools
            if "tools" in components:
                for tool_def in components["tools"]:
                    await self._install_plugin_tool(tool_def, installation)

            # Install resources
            if "resources" in components:
                for resource_def in components["resources"]:
                    await self._install_plugin_resource(resource_def, installation)

            # Install prompts
            if "prompts" in components:
                for prompt_def in components["prompts"]:
                    await self._install_plugin_prompt(prompt_def, installation)

        except Exception as e:
            logging.error(f"Error installing plugin components: {e}")
            raise

    async def _install_plugin_tool(self, tool_def: Dict[str, Any], installation: PluginInstallation):
        """Install a plugin tool."""
        try:
            # Create tool handler
            async def plugin_tool_handler(*args, **kwargs):
                # This would implement the actual tool logic
                # For now, we'll create a placeholder
                return {
                    "plugin_id": installation.plugin_id,
                    "tool_name": tool_def["name"],
                    "result": "Tool execution result would go here",
                    "args": args,
                    "kwargs": kwargs
                }

            # Register tool (this would integrate with the main MCP server)
            logging.info(f"Installed plugin tool: {tool_def['name']}")

        except Exception as e:
            logging.error(f"Error installing plugin tool: {e}")
            raise

    async def get_installed_plugins(self, organization_id: str) -> List[Dict[str, Any]]:
        """Get installed plugins for an organization."""
        try:
            async with self.postgres_pool.acquire() as conn:
                installations = await conn.fetch(
                    """
                    SELECT
                        pi.*,
                        p.name,
                        p.description,
                        p.version,
                        p.author,
                        p.category
                    FROM mcp_plugin_installations pi
                    JOIN mcp_plugins p ON pi.plugin_id = p.id
                    WHERE pi.organization_id = $1
                    ORDER BY pi.installed_at DESC
                    """,
                    organization_id
                )

                return [dict(installation) for installation in installations]

        except Exception as e:
            logging.error(f"Error getting installed plugins: {e}")
            raise

    async def uninstall_plugin(
        self,
        plugin_id: str,
        organization_id: str
    ) -> bool:
        """Uninstall an MCP plugin."""
        try:
            async with self.postgres_pool.acquire() as conn:
                # Remove installation record
                result = await conn.execute(
                    """
                    DELETE FROM mcp_plugin_installations
                    WHERE plugin_id = $1 AND organization_id = $2
                    """,
                    plugin_id, organization_id
                )

                if result == "DELETE 0":
                    return False

                # Update install count
                await conn.execute(
                    """
                    UPDATE mcp_plugins
                    SET install_count = GREATEST(0, install_count - 1)
                    WHERE id = $1
                    """,
                    plugin_id
                )

                # Remove from memory
                installation_to_remove = None
                for inst_id, installation in self.installed_plugins.items():
                    if (installation.plugin_id == plugin_id and
                        installation.organization_id == organization_id):
                        installation_to_remove = inst_id
                        break

                if installation_to_remove:
                    del self.installed_plugins[installation_to_remove]

                logging.info(f"Plugin {plugin_id} uninstalled from org {organization_id}")
                return True

        except Exception as e:
            logging.error(f"Error uninstalling plugin: {e}")
            raise
```

### 3. MCP Client Integration (`app/mcp_integration/client.py`):
```python
import asyncio
import json
import logging
from typing import Dict, List, Any, Optional, AsyncGenerator
from dataclasses import dataclass
import httpx

from mcp.client.session import ClientSession
from mcp.client.stdio import StdioServerParameters, stdio_client
from mcp.client.streamable_http import streamablehttp_client
from mcp import types

@dataclass
class MCPConnection:
    """MCP connection configuration."""
    name: str
    transport: str  # stdio, sse, streamable-http
    url: Optional[str] = None
    command: Optional[str] = None
    args: Optional[List[str]] = None
    env: Optional[Dict[str, str]] = None
    auth_token: Optional[str] = None

class MCPClientManager:
    """Manager for MCP client connections."""

    def __init__(self):
        self.connections: Dict[str, MCPConnection] = {}
        self.active_sessions: Dict[str, ClientSession] = {}

    async def register_connection(self, connection: MCPConnection):
        """Register an MCP connection."""
        self.connections[connection.name] = connection
        logging.info(f"Registered MCP connection: {connection.name}")

    async def connect(self, connection_name: str) -> ClientSession:
        """Connect to an MCP server."""
        if connection_name not in self.connections:
            raise ValueError(f"Unknown connection: {connection_name}")

        connection = self.connections[connection_name]

        try:
            if connection.transport == "stdio":
                async with stdio_client(
                    StdioServerParameters(
                        command=connection.command,
                        args=connection.args or [],
                        env=connection.env
                    )
                ) as (read, write):
                    session = ClientSession(read, write)
                    await session.initialize()
                    self.active_sessions[connection_name] = session
                    return session

            elif connection.transport == "streamable-http":
                async with streamablehttp_client(
                    connection.url,
                    headers={"Authorization": f"Bearer {connection.auth_token}"} if connection.auth_token else None
                ) as (read, write, _):
                    session = ClientSession(read, write)
                    await session.initialize()
                    self.active_sessions[connection_name] = session
                    return session

            else:
                raise ValueError(f"Unsupported transport: {connection.transport}")

        except Exception as e:
            logging.error(f"Error connecting to {connection_name}: {e}")
            raise

    async def call_tool(
        self,
        connection_name: str,
        tool_name: str,
        arguments: Dict[str, Any]
    ) -> Any:
        """Call a tool on an MCP server."""
        if connection_name not in self.active_sessions:
            await self.connect(connection_name)

        session = self.active_sessions[connection_name]

        try:
            result = await session.call_tool(tool_name, arguments)
            return result

        except Exception as e:
            logging.error(f"Error calling tool {tool_name}: {e}")
            raise

    async def list_tools(self, connection_name: str) -> List[types.Tool]:
        """List tools available on an MCP server."""
        if connection_name not in self.active_sessions:
            await self.connect(connection_name)

        session = self.active_sessions[connection_name]
        return await session.list_tools()

    async def read_resource(
        self,
        connection_name: str,
        resource_uri: str
    ) -> tuple[Any, str]:
        """Read a resource from an MCP server."""
        if connection_name not in self.active_sessions:
            await self.connect(connection_name)

        session = self.active_sessions[connection_name]
        return await session.read_resource(types.AnyUrl(resource_uri))
```

## Dependencies
- MCP Python SDK for protocol implementation
- FastMCP for high-level server implementation
- aioredis for caching and session management
- asyncpg for database operations
- httpx for HTTP client operations
- pydantic for data validation

## Acceptance Criteria
- [ ] MCP server supports all core protocol features with 100% compliance
- [ ] Integration with 5+ external tools achieves <100ms operation latency
- [ ] Plugin marketplace supports installation and management of 20+ extensions
- [ ] Security model prevents unauthorized access to sensitive resources
- [ ] Protocol compatibility maintained with MCP specification updates
- [ ] Cross-platform interoperability verified with major MCP clients

## Time Estimate
**Total: 20-25 days**
- MCP server core implementation: 7-9 days
- Plugin marketplace development: 6-8 days
- Client integration and tools: 4-5 days
- Security and access control: 3-4 days
- Testing and validation: 2-3 days

## Required Skills
- Model Context Protocol (MCP) specification knowledge
- Advanced Python async programming
- Protocol implementation and JSON-RPC
- Plugin architecture design
- Security and access control patterns
- Cross-platform compatibility testing

## Risks
- **High**: MCP specification changes requiring protocol updates
- **Medium**: Plugin security and sandboxing complexity
- **Medium**: Cross-platform compatibility challenges
- **Low**: Performance impact of protocol overhead

## Additional Notes
- Implement comprehensive logging for all MCP operations
- Use feature flags for gradual rollout of new protocol features
- Ensure backward compatibility with older MCP versions
- Consider implementing protocol extensions for Mobius-specific features
