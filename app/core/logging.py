"""
Core logging configuration using structlog.

This module provides structured JSON logging configuration with:
- Environment-specific log levels
- Sensitive data masking
- Process information tracking
- Structured JSON output for production
- Pretty console output for development
"""

import logging
import os
from typing import Any, Dict, List, Optional

import structlog
from pydantic import BaseModel, Field


class LogConfig(BaseModel):
    """Logging configuration settings."""

    level: str = Field("INFO", description="Default log level")
    format: str = Field("json", description="Log format (json or console)")
    correlation_id_header: str = Field(
        "X-Correlation-ID", description="Header name for correlation ID"
    )
    mask_fields: List[str] = Field(
        default_factory=lambda: [
            "password",
            "secret",
            "token",
            "api_key",
            "authorization",
        ],
        description="Field names to mask in logs",
    )
    include_process_info: bool = Field(
        True, description="Include process information in logs"
    )
    include_timestamp: bool = Field(True, description="Include timestamps in logs")


class SensitiveDataMasker:
    """Processor for masking sensitive data in logs."""

    def __init__(self, mask_fields: List[str]):
        """
        Initializes the SensitiveDataMasker with a list of field names to mask in log events.

        Args:
            mask_fields (List[str]): List of field names whose values should be masked in log output.

        Generated by CodeRabbit
        """
        self.mask_fields = mask_fields
        self._mask_value = "***MASKED***"

    def __call__(
        self, logger: Any, method_name: str, event_dict: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Recursively processes a log event dictionary to mask sensitive fields.

        Sensitive fields, as defined during initialization, are replaced with "***MASKED***" in the event dictionary. The masking is applied deeply to nested dictionaries and lists.

        Args:
            logger (Any): The logger instance (unused, required by structlog processor interface).
            method_name (str): The name of the logging method (unused, required by structlog processor interface).
            event_dict (Dict[str, Any]): The log event dictionary to process.

        Returns:
            Dict[str, Any]: The event dictionary with sensitive fields masked.

        Generated by CodeRabbit
        """
        return self._mask_dict(event_dict)

    def _mask_dict(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recursively masks sensitive fields in a dictionary by replacing their values with a masked placeholder.

        Args:
            data (Dict[str, Any]): The dictionary to process for sensitive field masking.

        Returns:
            Dict[str, Any]: A new dictionary with sensitive fields masked. Nested dictionaries and lists are processed recursively.

        Generated by CodeRabbit
        """
        masked = {}
        for key, value in data.items():
            if any(field in key.lower() for field in self.mask_fields):
                masked[key] = self._mask_value
            elif isinstance(value, dict):
                masked[key] = self._mask_dict(value)
            elif isinstance(value, list):
                masked[key] = [
                    self._mask_dict(item) if isinstance(item, dict) else item
                    for item in value
                ]
            else:
                masked[key] = value
        return masked


def setup_logging(
    log_config: Optional[LogConfig] = None, environment: Optional[str] = None
) -> None:
    """
    Configures structured logging for the application using the provided logging configuration and environment.

    This function sets up `structlog` with processors for log level filtering, sensitive data masking, timestamping, stack info, and environment-specific exception formatting. It also configures the output format (JSON or pretty console) and includes process metadata if enabled. The standard Python logging is also initialized with the appropriate log level.

    Args:
        log_config (Optional[LogConfig]): Logging configuration settings. If not provided, defaults are used.
        environment (Optional[str]): The environment name (e.g., "development", "production"). If not provided, uses the ENVIRONMENT environment variable or defaults to "development".

    Returns:
        None

    Example:
        >>> setup_logging()
        >>> logger = get_logger(__name__)
        >>> logger.info("Application started", user_id=123)

    Generated by CodeRabbit
    """
    if log_config is None:
        log_config = LogConfig()

    if environment is None:
        environment = os.getenv("ENVIRONMENT", "development")

    # Set log level based on environment
    if environment == "production":
        log_level = getattr(logging, log_config.level.upper(), logging.INFO)
    else:
        log_level = logging.DEBUG

    # Configure processors
    processors = [
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
    ]

    # Add sensitive data masker
    processors.append(SensitiveDataMasker(log_config.mask_fields))

    # Environment-specific processors
    if environment == "development":
        processors.append(structlog.processors.format_exc_info)
    else:
        # In production, we want exception info but not full stack traces
        def format_exception_short(_, __, event_dict):
            """
            Shortens exception information in a log event dictionary to only include the exception type and message.

            Args:
                _ (Any): Unused positional argument, present for processor compatibility.
                __ (Any): Unused positional argument, present for processor compatibility.
                event_dict (dict): The log event dictionary potentially containing an "exception" key.

            Returns:
                dict: The updated event dictionary with the "exception" field truncated to its first line, if present.

            Example:
                >>> event = {"exception": "ValueError: Invalid input\\nTraceback (most recent call last):\\n..."}
                >>> format_exception_short(None, None, event)
                {'exception': 'ValueError: Invalid input'}

            Generated by CodeRabbit
            """
            if "exception" in event_dict and event_dict["exception"]:
                # Extract just the exception type and message
                exc_lines = str(event_dict["exception"]).split("\n")
                if exc_lines:
                    # Keep only the first line (exception type and message)
                    event_dict["exception"] = exc_lines[0]
            return event_dict

        processors.append(format_exception_short)

    # Add process info if configured
    if log_config.include_process_info:
        processors.append(
            structlog.processors.CallsiteParameterAdder(
                {
                    structlog.processors.CallsiteParameter.FILENAME,
                    structlog.processors.CallsiteParameter.FUNC_NAME,
                    structlog.processors.CallsiteParameter.LINENO,
                }
            )
        )

    # Choose renderer based on environment
    if environment == "development" and log_config.format != "json":
        # Pretty console output for development
        processors.append(structlog.dev.ConsoleRenderer())
    else:
        # JSON renderer for production or when explicitly requested
        processors.append(structlog.processors.JSONRenderer())

    # Configure structlog
    structlog.configure(
        processors=processors,
        wrapper_class=structlog.stdlib.BoundLogger,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

    # Configure standard library logging
    logging.basicConfig(
        format="%(message)s",
        level=log_level,
    )


def get_logger(name: str) -> structlog.stdlib.BoundLogger:
    """
    Returns a configured structlog logger instance bound to the specified name.

    Args:
        name (str): The name to associate with the logger, typically the module's `__name__`.

    Returns:
        structlog.stdlib.BoundLogger: A logger instance configured according to the current logging setup.

    Generated by CodeRabbit
    """
    return structlog.get_logger(name)
